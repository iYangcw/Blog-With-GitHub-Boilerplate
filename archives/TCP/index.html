<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,熊猫小A,Galileo,blog" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Galileo" />
    <link rel="alternate" type="application/rss+xml" title="个人博客 &raquo; RSS 2.0" href="/Blog-With-GitHub-Boilerplate/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="个人博客 &raquo; ATOM 1.0" href="/Blog-With-GitHub-Boilerplate/feed/atom/index.xml" />
    <link rel="stylesheet" href="/Blog-With-GitHub-Boilerplate/assets/galileo-3f4dcc35c9.css">
    <link rel="stylesheet" href="/Blog-With-GitHub-Boilerplate/assets/ExSearch/ExSearch-182e5a8868.css">
    <link rel="stylesheet" href="/Blog-With-GitHub-Boilerplate/assets/katex.min.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700&display=swap">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "/Blog-With-GitHub-Boilerplate/d45729b0250bfbbf5f167fb226f143fb.json"
        }
    </script>
    
<title>TCP半连接和全连接队列 - 个人博客</title>
<meta name="author" content="Sai" />
<meta name="description" content="关于TCP半连接和全连接队列问题" />
<meta property="og:title" content="TCP半连接和全连接队列 - 个人博客" />
<meta property="og:description" content="关于TCP半连接和全连接队列问题" />
<meta property="og:site_name" content="个人博客" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/Blog-With-GitHub-Boilerplate/archives/TCP/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2023-03-28T14:50:00-00.00" />
<meta name="twitter:title" content="TCP半连接和全连接队列 - 个人博客" />
<meta name="twitter:description" content="关于TCP半连接和全连接队列问题" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />

    </head>
    
    <body>
        
        <div class="container">
            <header id="ga-header">
                <div first>
                    <aside id="ga-brand">
                        <h1 class="brand"><a class="no-style" href="/Blog-With-GitHub-Boilerplate/">个人博客</a></h1>
                        <p>只坚持一种正义。我的正义。</p>
                    </aside>
                </div>
                <div second id="ga-nav">
                    <nav class="navs">
                        <ul><li><a class="ga-highlight" href="/Blog-With-GitHub-Boilerplate/" target="_self">首页</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/Blog-With-GitHub-Boilerplate/archives/" target="_self">归档</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/Blog-With-GitHub-Boilerplate/about/" target="_self">关于</a></li><span class="separator">·</span><li><a href="#" target="_self" class="search-form-input ga-highlight">搜索</a></li></ul>
                    </nav>
                </div>
            </header>
            <div class="wrapper">
                
<main>    
    <section class="ga-section ga-content">
        <article class="yue">
            <h1 class="ga-post_title">TCP半连接和全连接队列</h1>
            <span class="ga-post_meta ga-mono">
                <span>Sai</span>
                <time>
                    2023-03-28
                </time>
                
                in <a no-style class="category" href="/Blog-With-GitHub-Boilerplate/category/Maverick/">
                    Maverick
                </a>
                
                
            </span>
            <div class="ga-content_body">
                <p>原始文档为以下三篇，根据相关文档进行的整理。</p>
<p><a href="https://mp.weixin.qq.com/s/YpSlU1yaowTs-pF6R43hMw">从一次线上问题说起，详解 TCP 半连接队列、全连接队列</a></p>
<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97">TCP 半连接队列和全连接队列</a></p>
<p><a href="https://docs.google.com/spreadsheets/d/1uz_1QSTsegHr6qqmq0PG1Y6c6RLFz5Y2FfkCma9jTkY/edit?usp=sharing">详解 TCP 半连接队列与全连接队列</a></p>
<p>另外，Linux 源码请看 <a href="https://elixir.bootlin.com/linux/v3.10/source">https://elixir.bootlin.com/linux/v3.10/source</a> ，可以快速跳转。</p>
<p>全连接以及不开启cookie的半连接，Linux 3.10.0 的结果能分析出来，但是开了cookie的半连接，试验数据一直对不上。</p>
<h1>1、基础信息</h1>
<h2>1.1、服务端和客户端信息</h2>
<p>本试验的 Linux 内核版本：3.10.0，以下均是基于此分析。</p>
<h2>1.2、ss 命令</h2>
<p>ss 利用到了 TCP 协议栈中的 tcp_diag（见 1.4 的分析）。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，这就确保了 ss 的快捷高效。当然，如果你的系统中没有 tcp_diag，ss 也可以正常运行，只是效率会变得稍慢。</p>
<p>在「LISTEN 状态」时，<code>Recv-Q/Send-Q</code> 表示的含义如下：</p>
<ul>
<li><p>Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 <code>accept()</code> 的 TCP 连接；</p>
</li>
<li><p>Send-Q：当前全连接最大队列长度，下面的输出结果说明监听 8088 端口的 TCP 服务，最大全连接长度为 128；</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># -l , --listening 显示监听状态的套接字（sockets）</span>
<span class="c1"># -n , --numeric   不解析服务名称</span>
<span class="c1"># -t , --tcp       仅显示 TCP套接字（sockets）</span>
$<span class="w"> </span>ss<span class="w"> </span>-lnt
State<span class="w">       </span>Recv-Q<span class="w"> </span>Send-Q<span class="w">            </span>Local<span class="w"> </span>Address:Port<span class="w">                           </span>Peer<span class="w"> </span>Address:Port
LISTEN<span class="w">      </span><span class="m">6</span><span class="w">      </span><span class="m">128</span><span class="w">                        </span><span class="o">[</span>::<span class="o">]</span>:8888<span class="w">                                   </span><span class="o">[</span>::<span class="o">]</span>:*
</pre></div>
<p>在「非 LISTEN 状态」时，<code>Recv-Q/Send-Q</code> 表示的含义如下：</p>
<ul>
<li>Recv-Q：已收到但未被应用进程读取的字节数；</li>
<li>Send-Q：已发送但未收到确认的字节数；</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># -n , --numeric   不解析服务名称</span>
<span class="c1"># -t , --tcp       仅显示 TCP套接字（sockets）</span>
$<span class="w"> </span>ss<span class="w"> </span>-nt
State<span class="w">       </span>Recv-Q<span class="w"> </span>Send-Q<span class="w">            </span>Local<span class="w"> </span>Address:Port<span class="w">                           </span>Peer<span class="w"> </span>Address:Port
ESTAB<span class="w">       </span><span class="m">0</span><span class="w">      </span><span class="m">36</span><span class="w">               </span><span class="m">192</span>.168.56.101:22<span class="w">                             </span><span class="m">192</span>.168.56.1:12656
CLOSE-WAIT<span class="w">  </span><span class="m">12</span><span class="w">     </span><span class="m">0</span><span class="w">       </span><span class="o">[</span>::ffff:192.168.56.101<span class="o">]</span>:8888<span class="w">                </span><span class="o">[</span>::ffff:192.168.56.100<span class="o">]</span>:34204
</pre></div>
<h2>1.3、netstat 命令</h2>
<p>通过 <code>netstat -s</code> 命令可以查看 TCP 半连接队列、全连接队列的溢出情况</p>
<p>下面输出的数值是累计值，分别表示有多少 TCP socket 链接因为全连接队列、半连接队列满了而被丢弃</p>
<p>注意 <strong>times</strong> 是次数，不是时间的意思。</p>
<p><strong>在排查线上问题时，如果一段时间内相关数值一直在上升，则表明半连接队列、全连接队列有溢出情况</strong></p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>netstat<span class="w"> </span>-s<span class="w"> </span><span class="p">|</span>grep<span class="w"> </span>-i<span class="w"> </span>listen
<span class="w">    </span><span class="m">911</span><span class="w"> </span><span class="nb">times</span><span class="w"> </span>the<span class="w"> </span>listen<span class="w"> </span>queue<span class="w"> </span>of<span class="w"> </span>a<span class="w"> </span>socket<span class="w"> </span>overflowed
<span class="w">    </span><span class="m">911</span><span class="w"> </span>SYNs<span class="w"> </span>to<span class="w"> </span>LISTEN<span class="w"> </span>sockets<span class="w"> </span>dropped
</pre></div>
<h2>1.4、tcp_diag.c  分析</h2>
<p>不同内核版本的 tcp_diag.c 的代码是不一样的，本试验的 Linux 内核版本：3.10.0</p>
<p><code>ss</code> 命令获取的 <code>Recv-Q/Send-Q</code> 在「LISTEN 状态」和「非 LISTEN 状态」所表达的含义是不同的，见3.10.0的内核代码。</p>
<div class="highlight"><pre><span></span><span class="c1">// https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/tcp_diag.c</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">tcp_diag_get_info</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inet_diag_msg</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">,</span>
<span class="w">                  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">_info</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_sock</span><span class="w"> </span><span class="o">*</span><span class="n">tp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_info</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_info</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 如果 TCP 连接状态是 LISTEN 时</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TCP_LISTEN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 当前全连接队列的大小</span>
<span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">idiag_rqueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 当前全连接的最大队列长度</span>
<span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">idiag_wqueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 如果 TCP 连接状态不是 LISTEN 时</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 已收到但未被应用进程读取的字节数</span>
<span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">idiag_rqueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// 已发送但未收到确认的字节数</span>
<span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">idiag_wqueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">        </span><span class="n">tcp_get_info</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<h2>1.5、Accept Queue：全连接队列的结论</h2>
<p>Accept Queue：全连接队列</p>
<p>最大队列为：<code>min(backlog, net.core.somaxconn)</code></p>
<p>校验 Accept Queue 是否满的逻辑如下（ 注意大于号才返回ture，即最终可存储 <strong>socket 数目会加1</strong>）：</p>
<p><code>return sk-&gt;sk_ack_backlog &gt; sk-&gt;sk_max_ack_backlog</code></p>
<h2>1.6、SYN Queue：半连接队列的结论</h2>
<p>半连接的逻辑比较复杂，算出最大连接后，还有其他逻辑进行判断。实际测试下来的情况，不开启 cookie 的结果和结论能对的上，但是开启 cookie 后，测试的结果对不上（以后再进行分析，目前一直无法测试到结果）</p>
<p><strong>不开启cookie的结论如下</strong></p>
<p>1、半连接最大连接 &gt; 0.75*tcp_max_syn_backlog，则 Drop SYN临界值为 0.75*tcp_max_syn_backlog +1【+1是因为判断条件是大于号】</p>
<p>2、半连接最大连接 &lt;= 0.75*tcp_max_syn_backlog，则 Drop SYN临界值为 半连接最大连接</p>
<p>【tcp_v4_conn_request 函数的第三处判断，按照代码判断 = 应是 2 的结论，但是由于 256除以0.75 不是整数，无法进一步确认 等于号 =】</p>
<p><strong>开启cookie的结论如下：</strong></p>
<p>按照网上说的，应是当半连接队列长度 &gt; 全连接队列最大长度时，就会触发 DROP SYN 请求。但是目前我测试下来，SYN_RECV 的数量无法达到上限，无法验证结果。【<strong>后续再研究，目前测试一直无法得出啥结论</strong>】</p>
<h3>1.6.1、半连接队列最大长度控制</h3>
<p>由于C语言已忘记，计算公式无法确认，以下信息为借鉴。</p>
<p>很多博文中说半连接队列最大长度由 /proc/sys/net/ipv4/tcp_max_syn_backlog 参数指定，<strong>实际上只有在 linux 内核版本小于 2.6.20 时，半连接队列才等于 backlog 的大小</strong>。</p>
<div class="highlight"><pre><span></span><span class="c1">// max_qlen_log - log_2 of maximal queued SYNs/REQUESTs</span>
<span class="c1">// 也就是说 最大半连接队列 等于 2 的 max_qlen_log 次方</span>
<span class="n">nr_table_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span><span class="w"> </span><span class="n">nr_table_entries</span><span class="p">,</span><span class="w"> </span><span class="n">sysctl_max_syn_backlog</span><span class="p">);</span>
<span class="n">nr_table_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span><span class="w"> </span><span class="n">nr_table_entries</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="n">nr_table_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">nr_table_entries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="c1">//向上取满足2的指数倍的整数</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">lopt</span><span class="o">-&gt;</span><span class="n">max_qlen_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">     </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lopt</span><span class="o">-&gt;</span><span class="n">max_qlen_log</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nr_table_entries</span><span class="p">;</span>
<span class="w">     </span><span class="n">lopt</span><span class="o">-&gt;</span><span class="n">max_qlen_log</span><span class="o">++</span><span class="p">);</span>

<span class="c1">//大体计算过程如下</span>
<span class="n">backlog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">somaxconn</span><span class="p">,</span><span class="w"> </span><span class="n">backlog</span><span class="p">)</span>
<span class="n">nr_table_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">backlog</span>
<span class="n">nr_table_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">backlog</span><span class="p">,</span><span class="w"> </span><span class="n">sysctl_max_syn_backlog</span><span class="p">)</span>
<span class="n">nr_table_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">nr_table_entries</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span>
<span class="c1">// roundup_pow_of_two: 将参数向上取整到最小的 2^n</span>
<span class="c1">// 注意这里存在一个 +1</span>
<span class="n">nr_table_entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">nr_table_entries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">max_qlen_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">log2</span><span class="p">(</span><span class="n">nr_table_entries</span><span class="p">))</span>
<span class="n">max_queue_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="n">max_qlen_log</span>
</pre></div>
<p>sysctl_max_syn_backlog 即内核参数 net.ipv4.tcp_max_syn_backlog （3.10.0 代码默认值是256，但是系统参数是128）</p>
<p>2^max_qlen_log^ 也就是最大情况为 2^log2{nr_table_entries}^ ,也就是 nr_table_entries 的值；最小为 8</p>
<p>有一点绕，不过运算都很简单，半连接队列的长度实际上由三个参数决定</p>
<ul>
<li><code>listen</code> 时传入的 backlog</li>
<li><code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code></li>
<li><code>/proc/sys/net/core/somaxconn</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># 相关操作命令</span>
<span class="c1"># backlog，用的 Golang 测试，在 Golang 中，listen 的 backlog 参数使用的是 /proc/sys/net/core/somaxconn 文档中的值</span>
sudo<span class="w"> </span>sysctl<span class="w"> </span>-w<span class="w"> </span>net.core.somaxconn<span class="o">=</span><span class="m">128</span>
sudo<span class="w"> </span>sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.tcp_max_syn_backlog<span class="o">=</span><span class="m">512</span>
sudo<span class="w"> </span>sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.tcp_syncookies<span class="o">=</span><span class="m">1</span>
</pre></div>
<h3>1.6.2、判断是否 Drop SYN 请求</h3>
<p>当 Client 端向 Server 端发送 SYN 报文后，Server 端会将该 socket 连接存储到半连接队列(SYN Queue)，如果 Server 端判断半连接队列满了则会将连接 Drop 丢弃。</p>
<p>那么 Server 端是如何判断半连接队列是否满的呢？除了上面一小节提到的半连接队列最大长度控制外，还和 /proc/sys/net/ipv4/tcp_syncookies 参数有关。(tcp_syncookies 的作用是为了防止 SYN Flood 攻击的)</p>
<p><figure style="flex: 56.20031796502385" ><img width="707" height="629" src="https://raw.githubusercontent.com/iYangcw/Photo/master/sys_length_calc.png" /></figure></p>
<p><strong>注意：第一个判断条件 「当前半连接队列是否已超过半连接队列最大长度」在不同内核版本中的判断不一样，Linux 4.19.91 内核判断的是当前半连接队列长度是否 &gt;= 全连接队列最大长度。</strong></p>
<p>实际测试的结果如下，按照cookie是否开启进行测试验证。</p>
<p><a href="https://docs.google.com/spreadsheets/d/1uz_1QSTsegHr6qqmq0PG1Y6c6RLFz5Y2FfkCma9jTkY/edit?usp=sharing">Google 表格链接</a></p>
<p><strong>没开启cookie的结果如下：</strong></p>
<p>Linux 3.10.0 的测试结果如下：</p>
<p>字段 a = max(min(backlog,somaxconn,sysctl_max_sys_backlog),8)</p>
<p>半队列最大长度等于 <code>roundup_pow_of_two(a+1)</code></p>
<p>由于是 <code>Golang</code> 测试，backlog 等于 somaxconn</p>
<table>
<thead><tr>
<th>somaxconn</th>
<th>tcp_max_syn_backlog</th>
<th>tcp_max_syn_backlog * 0.75</th>
<th>a</th>
<th>半队列Max</th>
<th>全队列Max</th>
<th>Drop SYN 临界值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1024</td>
<td>128</td>
<td>96</td>
<td>128</td>
<td>256</td>
<td>1024</td>
<td>96+1=97</td>
</tr>
<tr>
<td>128</td>
<td>118</td>
<td>88.5</td>
<td>118</td>
<td>128</td>
<td>128</td>
<td>88.5+1=90</td>
</tr>
<tr>
<td>128</td>
<td>108</td>
<td>81</td>
<td>108</td>
<td>128</td>
<td>128</td>
<td>81+1=82</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1.5</td>
<td>8</td>
<td>16</td>
<td>3</td>
<td>1.5+1=3</td>
</tr>
<tr>
<td>128</td>
<td>512</td>
<td>384</td>
<td>128</td>
<td>256</td>
<td>128</td>
<td>256</td>
</tr>
<tr>
<td>128</td>
<td>342</td>
<td>256.5</td>
<td>128</td>
<td>256</td>
<td>128</td>
<td>256</td>
</tr>
<tr>
<td>128</td>
<td>340</td>
<td>255</td>
<td>128</td>
<td>256</td>
<td>128</td>
<td>255+1=256</td>
</tr>
<tr>
<td>128</td>
<td>338</td>
<td>253.5</td>
<td>128</td>
<td>256</td>
<td>128</td>
<td>253.1+1=254</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span>实验一：syncookies<span class="o">=</span><span class="m">0</span>，somaxconn<span class="o">=</span><span class="m">1024</span>，backlog<span class="o">=</span><span class="m">1024</span>，tcp_max_syn_backlog<span class="o">=</span><span class="m">128</span>
计算出的半连接队列最大长度为<span class="w"> </span><span class="m">256</span>
当半连接队列长度增长至<span class="w"> </span><span class="m">96</span>+1<span class="w"> </span>后，后续<span class="w"> </span>SYN<span class="w"> </span>请求就会触发<span class="w"> </span>Drop
<span class="c1"># 客户端进行压测</span>
hping3<span class="w"> </span>-S<span class="w"> </span>-p<span class="w"> </span><span class="m">8888</span><span class="w"> </span>--flood<span class="w"> </span><span class="m">192</span>.168.56.101
<span class="c1"># 服务端每秒获取 SYN_RECV 连接数</span>
<span class="k">while</span><span class="w"> </span>true<span class="p">;</span><span class="k">do</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$(</span>sudo<span class="w"> </span>netstat<span class="w"> </span>-nat<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>:8888<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s1">&#39;SYN_RECV&#39;</span><span class="w">  </span><span class="p">|</span><span class="w"> </span>wc<span class="w"> </span>-l<span class="k">)</span><span class="p">;</span>sleep<span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="k">done</span>
<span class="k">while</span><span class="w"> </span>true<span class="p">;</span><span class="k">do</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="k">$(</span>ss<span class="w"> </span>-n<span class="w"> </span>state<span class="w"> </span>syn-recv<span class="w"> </span><span class="nv">sport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>:8888<span class="w"> </span><span class="p">|</span><span class="w"> </span>wc<span class="w"> </span>-l<span class="k">)</span><span class="p">;</span>sleep<span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="k">done</span>

其他的参数试验见表格结果。
</pre></div>
<p><strong>开启cookie的结果如下：</strong></p>
<p>一直无法复现网上结果，待定！</p>
<h2>1.7、tcp_v4_conn_request 源码</h2>
<p>内核版本：3.10.0</p>
<p>TCP 第一次握手：收到 SYN 包 的 Linux 内核代码如下，下文缩减了大量代码，只保留了 TCP 办连接队列溢出的处理逻辑：</p>
<ul>
<li>半连接队列满了，且 isn 为 0，且没有开启 tcp_syncookies，则丢弃连接</li>
<li>全连接队列满了，且没有重传的包的连接请求多余1个，则会丢弃</li>
<li>禁用SYN Cookie机制，并且队列中剩余的连接请求数量小于最大队列长度的四分之一，同时<code>tcp_peer_is_proven</code>函数返回<code>false</code>（表明当前目标端无法被证明是存活的），那么连接请求将被拒绝并释放。</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/tcp_ipv4.c</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">tcp_v4_conn_request</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_options_received</span><span class="w"> </span><span class="n">tmp_opt</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">request_sock</span><span class="w"> </span><span class="o">*</span><span class="n">req</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inet_request_sock</span><span class="w"> </span><span class="o">*</span><span class="n">ireq</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_sock</span><span class="w"> </span><span class="o">*</span><span class="n">tp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dst_entry</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">saddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
<span class="w">    </span><span class="n">__be32</span><span class="w"> </span><span class="n">daddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">isn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">want_cookie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">flowi4</span><span class="w"> </span><span class="n">fl4</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_fastopen_cookie</span><span class="w"> </span><span class="n">foc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_fastopen_cookie</span><span class="w"> </span><span class="n">valid_foc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb_synack</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">do_fastopen</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* TW buckets are converted to open requests without</span>
<span class="cm">     * limitations, they conserve resources and peer is</span>
<span class="cm">     * evidently real one.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">// 1、半连接队列满了，且 isn 为 0，且没有开启 tcp_syncookies，则丢弃连接</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inet_csk_reqsk_queue_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">isn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">want_cookie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcp_syn_flood_action</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TCP&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">want_cookie</span><span class="p">)</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">drop</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Accept backlog is full. If we have already queued enough</span>
<span class="cm">     * of warm entries in syn queue, drop request. It is better than</span>
<span class="cm">     * clogging syn queue with openreqs with exponentially increasing</span>
<span class="cm">     * timeout.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">// 若此时 accept queue 也已满，并且 qlen_young 的值大于 1（即保存在 SYN queue 中未进行 SYN,ACK 重传的连接超过 1 个）</span>
<span class="w">    </span><span class="c1">// 则直接丢弃当前 SYN 包（相当于针对 SYN 进行了速率限制）</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sk_acceptq_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">inet_csk_reqsk_queue_young</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span><span class="w"> </span><span class="n">LINUX_MIB_LISTENOVERFLOWS</span><span class="p">);</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">drop</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">     </span><span class="c1">// 大体意思就是开启了 sysctl_tcp_syncookies ，则 want_cookie 为 true   </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">want_cookie</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">isn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cookie_v4_init_sequence</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mss</span><span class="p">);</span>
<span class="w">        </span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cookie_ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">tstamp_ok</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* VJ&#39;s idea. We save last timestamp seen</span>
<span class="cm">         * from the destination in peer table, when entering</span>
<span class="cm">         * state TIME-WAIT, and check against it before</span>
<span class="cm">         * accepting new connection request.</span>
<span class="cm">         *</span>
<span class="cm">         * If &quot;isn&quot; is not zero, this request hit alive</span>
<span class="cm">         * timewait bucket, so that all the necessary checks</span>
<span class="cm">         * are made in the function processing timewait state.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tmp_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="n">tcp_death_row</span><span class="p">.</span><span class="n">sysctl_tw_recycle</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="p">(</span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inet_csk_route_req</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fl4</span><span class="p">,</span><span class="w"> </span><span class="n">req</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="n">fl4</span><span class="p">.</span><span class="n">daddr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">saddr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tcp_peer_is_proven</span><span class="p">(</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span><span class="w"> </span><span class="n">LINUX_MIB_PAWSPASSIVEREJECTED</span><span class="p">);</span>
<span class="w">                </span><span class="k">goto</span><span class="w"> </span><span class="n">drop_and_release</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/* Kill the following clause, if you dislike this way. */</span>
<span class="w">        </span><span class="c1">// 3--不开启cookie的情况，inet_csk_reqsk_queue_len为当前队列大小</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sysctl_tcp_syncookies</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">             </span><span class="p">(</span><span class="n">sysctl_max_syn_backlog</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">inet_csk_reqsk_queue_len</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span>
<span class="w">              </span><span class="p">(</span><span class="n">sysctl_max_syn_backlog</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">             </span><span class="o">!</span><span class="n">tcp_peer_is_proven</span><span class="p">(</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Without syncookies last quarter of</span>
<span class="cm">             * backlog is filled with destinations,</span>
<span class="cm">             * proven to be alive.</span>
<span class="cm">             * It means that we continue to communicate</span>
<span class="cm">             * to destinations, already remembered</span>
<span class="cm">             * to the moment of synflood.</span>
<span class="cm">             */</span>
<span class="w">            </span><span class="n">LIMIT_NETDEBUG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="w"> </span><span class="n">pr_fmt</span><span class="p">(</span><span class="s">&quot;drop open request from %pI4/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span>
<span class="w">                       </span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span><span class="w"> </span><span class="n">ntohs</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">));</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">drop_and_release</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">isn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcp_v4_init_sequence</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snt_isn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isn</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h2>1.8、SYN 和 ACCEPT 连接图</h2>
<p><figure style="flex: 50.709219858156025" ><img width="1144" height="1128" src="https://raw.githubusercontent.com/iYangcw/Photo/master/SYN%20Queue%20and%20Accept%20Queue.png" /></figure></p>
<p><code>TCP</code>连接创建时，客户端通过发送<code>SYN</code>报文发起向处于监听状态的服务器发起连接，服务器为该连接分配一定的资源，并发送<code>SYN+ACK</code>报文。对服务器来说，此时该连接的状态称为<code>半连接</code>(<code>Half-Open</code>)，而当其之后收到客户端回复的<code>ACK</code>报文后，连接才算创建完成。在这个过程中，如果服务器一直没有收到<code>ACK</code>报文(比如在链路中丢失了)，服务器会在超时后重传<code>SYN+ACK</code>。</p>
<h1>2、全连接队列实战</h1>
<h2>2.1、结论</h2>
<p><strong>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</strong></p>
<p><strong>（准确点说应该是根据内核版本来确认代码里面的判断逻辑，目前暂时认为所有 Linux 的版本都是上面的结论）</strong></p>
<ul>
<li><p><code>somaxconn</code> 是 Linux 内核的参数，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值，默认值根据版本来，是128 或者 4096。</p>
<div class="highlight"><pre><span></span><span class="c1"># https://man7.org/linux/man-pages/man2/listen.2.html</span>
Since<span class="w"> </span>Linux<span class="w"> </span><span class="m">5</span>.4,<span class="w"> </span>the<span class="w"> </span>default<span class="w"> </span><span class="k">in</span><span class="w"> </span>this<span class="w"> </span>file<span class="w"> </span>is<span class="w"> </span><span class="m">4096</span><span class="p">;</span><span class="w"> </span><span class="k">in</span>
<span class="w">       </span>earlier<span class="w"> </span>kernels,<span class="w"> </span>the<span class="w"> </span>default<span class="w"> </span>value<span class="w"> </span>is<span class="w"> </span><span class="m">128</span>.<span class="w">  </span>In<span class="w"> </span>kernels<span class="w"> </span>before
<span class="w">       </span><span class="m">2</span>.4.25,<span class="w"> </span>this<span class="w"> </span>limit<span class="w"> </span>was<span class="w"> </span>a<span class="w"> </span>hard<span class="w"> </span>coded<span class="w"> </span>value,<span class="w"> </span>SOMAXCONN,<span class="w"> </span>with<span class="w"> </span>the
<span class="w">       </span>value<span class="w"> </span><span class="m">128</span>.
</pre></div>
</li>
<li><p><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小</p>
<p>&lt;Unix 网络编程&gt;将其描述为<strong>已完成的连接队列</strong>(<code>ESTABLISHED</code>)与<strong>未完成连接队列</strong>(<code>SYN_RCVD</code>)之和的上限</p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// https://elixir.bootlin.com/linux/v3.10/source/net/socket.c</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">listen</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">socket</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">fput_needed</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">somaxconn</span><span class="p">;</span>

<span class="w">    </span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">somaxconn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock_net</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">sysctl_somaxconn</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="n">backlog</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">somaxconn</span><span class="p">)</span>
<span class="w">            </span><span class="n">backlog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">somaxconn</span><span class="p">;</span>

<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">security_socket_listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">backlog</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="n">backlog</span><span class="p">);</span>

<span class="w">        </span><span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">fput_needed</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h2>2.2、测试方案</h2>
<ul>
<li>通过 <strong>wrk</strong> 对服务端的 <strong>nginx</strong> 发起压测来查看当前队列 <strong>Recv-Q</strong> 使用情况</li>
<li>通过 <strong>go</strong> 代码发起 <strong>http</strong> 请求：只负责 Listen 对应端口，而不执行 accept() TCP 连接，使TCP全连接队列溢出，抓包进行分析</li>
</ul>
<h2>2.3、wrk 操作过程</h2>
<p>系统参数配置信息如下</p>
<div class="highlight"><pre><span></span><span class="c1"># nginx 配置文件的backlog，默认为511，另外如果修改的话，nginx需要重启，reload 看下来 backlog 是不生效的</span>
<span class="nv">backlog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">511</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.core.somaxconn<span class="o">=</span><span class="m">128</span>
<span class="c1"># cookies 开启关闭都测试下</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.tcp_syncookies<span class="o">=</span><span class="m">0</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.tcp_syncookies<span class="o">=</span><span class="m">0</span>
<span class="c1"># net.ipv4.tcp_max_syn_backlog=512 默认值，没有修改</span>
<span class="c1"># tcp_max_syn_backlog 不动，3.10 内核上默认是 512，backlog 和 max_syn_backlog 应该是有一定关系的，应该不能超过 max_syn_backlog</span>
</pre></div>
<p>启动 nginx 服务后，通过 ss 确认 Send-Q 大小（按照 min(128,511) 原则，应是 128）</p>
<div class="highlight"><pre><span></span><span class="c1"># nginx 的端口为 80</span>
$<span class="w"> </span>ss<span class="w"> </span>-lnt
State<span class="w">       </span>Recv-Q<span class="w"> </span>Send-Q<span class="w">            </span>Local<span class="w"> </span>Address:Port<span class="w">                           </span>Peer<span class="w"> </span>Address:Port
LISTEN<span class="w">      </span><span class="m">0</span><span class="w">      </span><span class="m">128</span><span class="w">                           </span>*:80<span class="w">                                        </span>*:*
</pre></div>
<p>客户端压测过程：</p>
<div class="highlight"><pre><span></span><span class="c1"># 客户端发起 wrk 压测</span>
<span class="c1"># -t 20     表示 20 个线程（建议调大，否则有可能服务端能处理过来，Recv-Q 不会超标）</span>
<span class="c1"># -c 30000  表示 3 万个连接</span>
<span class="c1"># -d 60s    表示持续压测 60 秒</span>
$<span class="w"> </span><span class="nb">ulimit</span><span class="w"> </span>-n<span class="w"> </span><span class="m">1000000</span><span class="w"> </span><span class="c1"># 临时调大点，否则有可能提示 Too many open files</span>
$<span class="w"> </span>wrk<span class="w"> </span>-t<span class="w"> </span><span class="m">20</span><span class="w"> </span>-c<span class="w"> </span><span class="m">30000</span><span class="w"> </span>-d<span class="w"> </span>60s<span class="w"> </span>http://192.168.56.101:80
Running<span class="w"> </span>1m<span class="w"> </span><span class="nb">test</span><span class="w"> </span>@<span class="w"> </span>http://192.168.56.101:80
<span class="w">  </span><span class="m">20</span><span class="w"> </span>threads<span class="w"> </span>and<span class="w"> </span><span class="m">30000</span><span class="w"> </span>connections
<span class="w">  </span>Thread<span class="w"> </span>Stats<span class="w">   </span>Avg<span class="w">      </span>Stdev<span class="w">     </span>Max<span class="w">   </span>+/-<span class="w"> </span>Stdev
<span class="w">    </span>Latency<span class="w">   </span><span class="m">278</span>.14ms<span class="w">  </span><span class="m">197</span>.13ms<span class="w">   </span><span class="m">1</span>.99s<span class="w">    </span><span class="m">83</span>.94%
<span class="w">    </span>Req/Sec<span class="w">   </span><span class="m">131</span>.67<span class="w">    </span><span class="m">207</span>.18<span class="w">     </span><span class="m">1</span>.68k<span class="w">    </span><span class="m">90</span>.59%
<span class="w">  </span><span class="m">43677</span><span class="w"> </span>requests<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span>.01m,<span class="w"> </span><span class="m">55</span>.90MB<span class="w"> </span><span class="nb">read</span>
<span class="w">  </span>Socket<span class="w"> </span>errors:<span class="w"> </span>connect<span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nb">read</span><span class="w"> </span><span class="m">1022705</span>,<span class="w"> </span>write<span class="w"> </span><span class="m">0</span>,<span class="w"> </span>timeout<span class="w"> </span><span class="m">1369</span>
Requests/sec:<span class="w">    </span><span class="m">722</span>.80
Transfer/sec:<span class="w">      </span><span class="m">0</span>.93MB
</pre></div>
<p>服务端相关信息：<code>tcp_syncookies</code> 关闭，发现 Recv-Q 很快就到达 <strong>129</strong>，且几乎持续维持在这个值；反之如果开启了，Recv-Q 也达到过 <strong>129</strong>，但是波动很大。从常识上也能理解到开启 cookie 了有存在复用，所以当前连接队列会小一点。</p>
<div class="highlight"><pre><span></span><span class="c1"># 间隔一秒，定时检测 80 端口的 socket 连接信息</span>
$<span class="w"> </span><span class="k">while</span><span class="w"> </span>true<span class="p">;</span><span class="k">do</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;当前时间:&quot;</span><span class="k">$(</span>date<span class="w"> </span>+%T<span class="k">)</span><span class="p">;</span>ss<span class="w"> </span>-lnt<span class="w"> </span><span class="p">|</span>grep<span class="w"> </span>-E<span class="w"> </span><span class="s1">&#39;Send-Q|80&#39;</span><span class="p">;</span>sleep<span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="k">done</span>
当前时间:05:23:55
State<span class="w">      </span>Recv-Q<span class="w"> </span>Send-Q<span class="w"> </span>Local<span class="w"> </span>Address:Port<span class="w">               </span>Peer<span class="w"> </span>Address:Port<span class="w">              </span>
LISTEN<span class="w">     </span><span class="m">61</span><span class="w">     </span><span class="m">128</span><span class="w">          </span>*:80<span class="w">                       </span>*:*<span class="w">                  </span>
当前时间:05:23:56
State<span class="w">      </span>Recv-Q<span class="w"> </span>Send-Q<span class="w"> </span>Local<span class="w"> </span>Address:Port<span class="w">               </span>Peer<span class="w"> </span>Address:Port<span class="w">              </span>
LISTEN<span class="w">     </span><span class="m">129</span><span class="w">    </span><span class="m">128</span><span class="w">          </span>*:80<span class="w">                       </span>*:*
</pre></div>
<p><strong>且注意下，Recv-Q 的最大值就是 【全连接队列最大值 + 1】</strong></p>
<p>该现象是因为<strong>内核在判断全连接是否满</strong>的情况下，使用的是 &gt; 而非 &gt;= 。</p>
<div class="highlight"><pre><span></span><span class="c1">// https://github.com/torvalds/linux/blob/v3.10/include/net/sock.h</span>
<span class="c1">// 检测全连接队列是否已满的函数</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">sk_acceptq_is_full</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// sk_ack_backlog：当前全连接队列的大小</span>
<span class="w">    </span><span class="c1">// sk_max_ack_backlog：当前全连接的最大队列长度</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p><strong>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接</strong>，丢掉的 TCP 连接的个数会被统计起来，我们可以使用 netstat -s 命令来查看：注意下，</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>netstat<span class="w"> </span>-s<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-i<span class="w"> </span>listen
<span class="w">    </span><span class="m">180233</span><span class="w"> </span><span class="nb">times</span><span class="w"> </span>the<span class="w"> </span>listen<span class="w"> </span>queue<span class="w"> </span>of<span class="w"> </span>a<span class="w"> </span>socket<span class="w"> </span>overflowed
<span class="w">    </span><span class="m">594579</span><span class="w"> </span>SYNs<span class="w"> </span>to<span class="w"> </span>LISTEN<span class="w"> </span>sockets<span class="w"> </span>dropped
</pre></div>
<h2>2.4、go 抓包操作过程</h2>
<h3>2.4.1、go 代码</h3>
<p>为了方便实验，将 <strong>server</strong> 端的 <strong>somaxconn</strong> 全连接队列最大长度更新为 5，另外启动 go 服务后请通过 ss -lnt 确认是否生效</p>
<p><code>sudo sysctl -w net.core.somaxconn=128</code></p>
<p><code>ss -lnt |grep -E 'Send-Q|8888'</code></p>
<p>server 端</p>
<div class="highlight"><pre><span></span><span class="c1">// 只负责 Listen 对应端口而不执行 accept() TCP 连接</span>
<span class="c1">// server.go</span>
<span class="c1">// go build server.go</span>
<span class="c1">// ./server</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="s">&quot;log&quot;</span>
<span class="w">  </span><span class="s">&quot;net&quot;</span>
<span class="w">  </span><span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">l</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;:8888&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;failed to listen due to %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">l</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="w">  </span><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;listen :8888 success&quot;</span><span class="p">)</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>client 代码</p>
<div class="highlight"><pre><span></span><span class="c1">// client 端并发请求 10 次 server 端，成功创建 tcp 连接后向 server 端发送数据</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="s">&quot;context&quot;</span>
<span class="w">  </span><span class="s">&quot;log&quot;</span>
<span class="w">  </span><span class="s">&quot;net&quot;</span>
<span class="w">  </span><span class="s">&quot;os&quot;</span>
<span class="w">  </span><span class="s">&quot;os/signal&quot;</span>
<span class="w">  </span><span class="s">&quot;sync&quot;</span>
<span class="w">  </span><span class="s">&quot;syscall&quot;</span>
<span class="w">  </span><span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">establishConn</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="w">  </span><span class="nx">conn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">net</span><span class="p">.</span><span class="nx">DialTimeout</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;192.168.56.101:8888&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d, dial error: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d, dial success&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">  </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">conn</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d, send error: %v&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Done</span><span class="p">():</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d, dail close&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">cancel</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">establishConn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sc</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="nx">signal</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">sc</span><span class="p">,</span><span class="w"> </span><span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGINT</span><span class="p">)</span>
<span class="w">    </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">sc</span><span class="p">:</span>
<span class="w">      </span><span class="nx">cancel</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}()</span>
</pre></div>
<h3>2.4.2、操作过程</h3>
<p>服务端启动程序后，客户端按照以下命令开始抓包后，再执行客户端程序</p>
<p><code>sudo  tshark -Eheader=y -l -f "tcp port 8888" -i any -w client_to_server.pcap</code></p>
<h3>2.4.3、抓包结果分析</h3>
<p>第三步的抓包结果不是每次必现</p>
<h3>2.4.4、抓包结果-01</h3>
<p>正常连接</p>
<p><figure style="flex: 415.0900900900901" ><img width="1843" height="222" src="https://raw.githubusercontent.com/iYangcw/Photo/master/connect_01.png" /></figure></p>
<h3>2.4.5、抓包结果-02</h3>
<p><figure style="flex: 146.03053435114504" ><img width="1913" height="655" src="https://raw.githubusercontent.com/iYangcw/Photo/master/connect_02.png" /></figure></p>
<p>Client 认为成功与 Server 端创建 tcp socket 连接，后续发送数据失败，持续 RETRY;Server 端认为 TCP 连接未创建，一直在发送SYN+ACK。</p>
<p>Server 端为什么一直在 RETRY 发送 <code>SYN+ACK</code>? Server 端不是已经收到了 Client 端的 ACK 确认了吗?</p>
<p>上述情况是由于 Server 端 socket 连接进入了半连接队列，在收到 Client 端 ACK 后，本应将 socket 连接存储到全连接队列，但是全连接队列已满，所以 Server 端 DROP 了该 ACK 请求。</p>
<p>Server 端一直在 RETRY 发送 <code>SYN+ACK</code>，是因为 DROP 了 client 端的 ACK 请求，所以 socket 连接仍旧在半连接队列中，等待 Client 端回复 ACK。</p>
<p>全连接队列满 DROP 请求是默认行为，可以通过设置 <code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code> 使 Server 端在全连接队列满时，向 Client 端发送 RST 报文。</p>
<p><code>tcp_abort_on_overflow</code> 有两种可选值：</p>
<ul>
<li>0：如果全连接队列满了，Server 端 DROP Client 端回复的 ACK 【默认值】</li>
<li>1：如果全连接队列满了，Server 端向 Client 端发送 RST 报文，终止 TCP socket 链接</li>
</ul>
<h3>2.4.6、抓包结果-03</h3>
<p><figure style="flex: 447.4299065420561" ><img width="1915" height="214" src="https://raw.githubusercontent.com/iYangcw/Photo/master/connect_03.png" /></figure></p>
<p>Client 向 Server 发送 SYN 未得到相应，一直在 RETRY。</p>
<p>需要结合半连接队列来分析，结论如下</p>
<p>1、开启了 <code>/proc/sys/net/ipv4/tcp_syncookies</code> 功能</p>
<p>2、全连接队列满了</p>
<h1>3、半连接队列实战</h1>
<h2>3.1、结论</h2>
<p>见 1.6 结论</p>
<h2>3.2、内核代码分析</h2>
<p>见1.7</p>
<h3>3.2.1、半连接代码</h3>
<p>代码流程大致流程就是：</p>
<p>半连接队列满了，且 ISN 为0，则判断是否开启 cookie，如果开启了cookie 走其他逻辑，如果没开启cookie，则丢弃该包</p>
<p>大白话，个人理解如下（SYN洪水攻击的逻辑）：</p>
<p>这一部分应该是 SYN 洪水攻击避免的实现逻辑，SYN洪水攻击中，攻击者通常会将TCP握手过程中的调用方序列号（ISN）置为0，目的在于混淆目标主机，并使其无法正确地处理TCP连接请求。</p>
<p>所以方法的逻辑是 <code>!isn</code>，如果队列已满，且有 ISN=0 的情况，则走到 want_cookie 的逻辑；</p>
<p>如果不需要进行 cookie 验证，则直接跳转到 drop，即丢弃该数据包。</p>
<div class="highlight"><pre><span></span><span class="c1">// 半连接队列满了，且 isn 为 0：即没有生成初始序列号</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inet_csk_reqsk_queue_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">isn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">want_cookie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcp_syn_flood_action</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TCP&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">want_cookie</span><span class="p">)</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">drop</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">    第一处分析</span>
<span class="cm">    https://elixir.bootlin.com/linux/v3.10/source/include/net/inet_connection_sock.h#L297</span>
<span class="cm">    该函数主要通过调用reqsk_queue_is_full函数来判断TCP套接字的请求队列是否已满，函数输入参数为TCP套接字sk.</span>
<span class="cm">    在函数实现中，首先调用inet_csk函数获取TCP套接字的传输控制块，并通过icsk_accept_queue访问请求队列，从而判断该请求队列是否已满.</span>
<span class="cm">    队列已满,函数  返回 1;</span>
<span class="cm">    队列未满,函数  返回 0.</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">inet_csk_reqsk_queue_is_full</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">reqsk_queue_is_full</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">reqsk_queue_is_full</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">request_sock_queue</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     C语言不懂，查阅资料说是这段代码的意思是</span>
<span class="cm">     用于检查一个请求队列是否已满。该函数的作用是判断指定的请求队列是否已经达到了最大队列长度，如果达到最大长度则返回1，否则返回0。</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">listen_opt</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">listen_opt</span><span class="o">-&gt;</span><span class="n">max_qlen_log</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">    第二处分析：!isn，能正常往该函数继续往下走，也就是 isn 为 0</span>
<span class="cm">    一个TCP连接的ISN被设置为0，这意味着这个连接没有已知的初始序列号。这意味着发送方和接收方都将从初始位置开始传输数据。</span>

<span class="cm">    __u32 isn = TCP_SKB_CB(skb)-&gt;when;</span>
<span class="cm">    这段代码是从skb中获取TCP协议块的发送时间戳，并将其赋值给变量isn。</span>

<span class="cm">    __u32：unsigned 32-bit integer（无符号32位整数）</span>
<span class="cm">    TCP_SKB_CB(skb)是一个宏定义，用于获取指向TCP协议块头部的指针，这里使用when字段来表示该TCP协议块的发送时间戳。</span>
<span class="cm">*/</span>


<span class="cm">/*</span>
<span class="cm">    第三处分析：tcp_syn_flood_action</span>
<span class="cm">    https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/tcp_ipv4.c</span>
<span class="cm">    Return true if a syncookie should be sent</span>
<span class="cm">    大体意思就是开启了 sysctl_tcp_syncookies ，则 want_cookie 为 true</span>
<span class="cm">    这个参数默认值为1，可以通过修改 /proc/sys/net/ipv4/tcp_syncookies 文件或者使用sysctl命令进行修改</span>
<span class="cm">*/</span>
</pre></div>
<h3>3.2.2、全连接代码</h3>
<p>若此时 accept queue 也已满，并且 qlen_young 的值大于 1（即保存在 SYN queue 中未进行 SYN,ACK 重传的连接超过 1 个），则直接丢弃当前 SYN 包（相当于针对 SYN 进行了速率限制）</p>
<div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sk_acceptq_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">inet_csk_reqsk_queue_young</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span><span class="w"> </span><span class="n">LINUX_MIB_LISTENOVERFLOWS</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">drop</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>第一处代码分析如下</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">    https://elixir.bootlin.com/linux/v3.10/source/include/net/sock.h#L723</span>
<span class="cm">    如果TCP连接请求接收队列已满，则返回true。</span>
<span class="cm">    通过检查 backlog 和 sk_max_ack_backlog 字段的值，来决定TCP连接请求队列是否已满。</span>
<span class="cm">    sk_ack_backlog  当前全连接队列大小</span>
<span class="cm">    sk_max_ack_backlog  全连接队列最大值 min(somaxconn,backlog)</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">sk_acceptq_is_full</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//</span>
</pre></div>
<p>第二处代码分析如下</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">    https://elixir.bootlin.com/linux/v3.10/source/include/net/inet_connection_sock.h#L292</span>
<span class="cm">    看的不是很明白，qlen_young 没理解意思，机械理解成 保存在 SYN queue 中未进行 SYN,ACK 重传的连接</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">inet_csk_reqsk_queue_young</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">reqsk_queue_len_young</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// https://elixir.bootlin.com/linux/v3.10/source/include/net/request_sock.h#L252</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">reqsk_queue_len_young</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">request_sock_queue</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">listen_opt</span><span class="o">-&gt;</span><span class="n">qlen_young</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** struct listen_sock - listen state</span>
<span class="cm"> *</span>
<span class="cm"> * @max_qlen_log - log_2 of maximal queued SYNs/REQUESTs</span>
<span class="cm"> */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">listen_sock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">u8</span><span class="w">          </span><span class="n">max_qlen_log</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w">          </span><span class="n">synflood_warned</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* 2 bytes hole, try to use */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">qlen</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">qlen_young</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">clock_hand</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">hash_rnd</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w">         </span><span class="n">nr_table_entries</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">request_sock</span><span class="w"> </span><span class="o">*</span><span class="n">syn_table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
<h3>3.3.3、请求队列溢出时的逻辑</h3>
<p>代码展示了Linux内核中在TCP连接请求队列溢出时的逻辑</p>
<div class="highlight"><pre><span></span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sysctl_tcp_syncookies</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">             </span><span class="p">(</span><span class="n">sysctl_max_syn_backlog</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">inet_csk_reqsk_queue_len</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span>
<span class="w">              </span><span class="p">(</span><span class="n">sysctl_max_syn_backlog</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">             </span><span class="o">!</span><span class="n">tcp_peer_is_proven</span><span class="p">(</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Without syncookies last quarter of</span>
<span class="cm">             * backlog is filled with destinations,</span>
<span class="cm">             * proven to be alive.</span>
<span class="cm">             * It means that we continue to communicate</span>
<span class="cm">             * to destinations, already remembered</span>
<span class="cm">             * to the moment of synflood.</span>
<span class="cm">             */</span>
<span class="w">            </span><span class="n">LIMIT_NETDEBUG</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="w"> </span><span class="n">pr_fmt</span><span class="p">(</span><span class="s">&quot;drop open request from %pI4/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span>
<span class="w">                       </span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span><span class="w"> </span><span class="n">ntohs</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">));</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">drop_and_release</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
</pre></div>
<h1>4、参考文档</h1>
<p>从一次线上问题说起，详解 TCP 半连接队列、全连接队列</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/YpSlU1yaowTs-pF6R43hMw">https://mp.weixin.qq.com/s/YpSlU1yaowTs-pF6R43hMw</a></li>
</ul>
<p>深入浅出TCP中的SYN-Cookies</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000019292140">https://segmentfault.com/a/1190000019292140</a></li>
</ul>
<p>TCP 半连接队列和全连接队列</p>
<ul>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97">https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97</a></li>
</ul>
<p>详解 TCP 半连接队列与全连接队列</p>
<ul>
<li><a href="https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/">https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/</a></li>
</ul>
<p>从 Linux 源码看 Socket (TCP) 的 listen 及连接队列</p>
<ul>
<li><a href="https://my.oschina.net/alchemystar/blog/4672630">https://my.oschina.net/alchemystar/blog/4672630</a></li>
</ul>
<p>详解 TCP 半连接队列与全连接队列</p>
<ul>
<li><a href="https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/">https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/</a></li>
</ul>
<p>[内核源码] 网络协议栈 - listen (tcp)</p>
<ul>
<li><a href="https://wenfh2020.com/2021/07/21/kernel-sys-listen/">https://wenfh2020.com/2021/07/21/kernel-sys-listen/</a></li>
</ul>
<p>socket API 实现</p>
<ul>
<li><a href="http://blog.guorongfei.com/tags/socket/">http://blog.guorongfei.com/tags/socket/</a></li>
</ul>
<p>SYN packet handling in the wild</p>
<ul>
<li><a href="https://blog.cloudflare.com/syn-packet-handling-in-the-wild/">https://blog.cloudflare.com/syn-packet-handling-in-the-wild/</a></li>
</ul>

            </div>
        </article>
        <div id="ga-tags">
    
    <span class="ga-tag">
        <a class="ga-highlight" href="/Blog-With-GitHub-Boilerplate/tag/TCP/">#TCP</a>
    </span>
    
</div>
    </section>

    
<section id="ga-content_pager">

    <div class="next">
        <h3>没有了</h3>
        <p class="yue">这是最新的文章</p>
    </div>


    <div class="prev">
        <a class="ga-highlight" href="/Blog-With-GitHub-Boilerplate/archives/typography/">Hello World!</a>
        <p class="yue">这是一篇示例文章，在这里你可以看到常用页面元素的显示效果。</p>
    </div>

</section>


    

</main>

                <footer class="ga-mono" id="ga-footer">
                    <section>
                        <span id="ga-uptime"></span>
                        <span class="brand">个人博客</span>
                    </section>
                    <section>
                        <p class="copyright">
                            <span>Copyright © 2023 Clover</span>
                            <span>Powered by <a no-style href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Galileo</a></span>
                        </p>
                        <div class="copyright">
                            <span class="footer-addon">
                                
                            </span>
                            <nav class="social-links">
                                <ul><li><a class="no-style" title="Twitter" href="xxxx" target="_blank"><i class="gi gi-twitter"></i>Twitter</a></li></ul>
                            </nav>
                        </div>
                    </section>
                    <script>
                        var site_build_date = "2019-12-18T16:51+08:00"
                    </script>
                    <script src="/Blog-With-GitHub-Boilerplate/assets/galileo-dc4baa7cf4.js"></script>
                </footer>
            </div>
        </div>
    </div>

    <!--katex-->
    <script defer src="/Blog-With-GitHub-Boilerplate/assets/katex.min.js"></script>
    <script>
    mathOpts = {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\[", right: "\\]", display: true},
            {left: "$", right: "$", display: false},
            {left: "\\(", right: "\\)", display: false}
        ]
    };
    </script>
    <script defer src="/Blog-With-GitHub-Boilerplate/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    <script src="/Blog-With-GitHub-Boilerplate/assets/ExSearch/jquery.min.js"></script>
    <script src="/Blog-With-GitHub-Boilerplate/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    
    </body>
</html>