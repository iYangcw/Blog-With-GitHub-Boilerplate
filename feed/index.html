<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>个人博客</title><link>/Blog-With-GitHub-Boilerplate/</link><description>每天进步一点点</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>/Blog-With-GitHub-Boilerplate/logo.png</url><title>个人博客</title><link>/Blog-With-GitHub-Boilerplate/</link></image><language>zh-CN</language><lastBuildDate>Mon, 01 May 2023 09:40:54 +0806</lastBuildDate><pubDate>Mon, 01 May 2023 09:40:54 +0806</pubDate><item><title>Hello World!</title><link>/Blog-With-GitHub-Boilerplate/archives/typography/</link><description>&lt;div class="notice"&gt;这是一篇示例文章，在这里你可以看到常用页面元素的显示效果，同时也是 Markdown 语法的参考文章。保留或者删除本文，开始自己的创作吧！&lt;/div&gt;&lt;h2&gt;L2 Heading&lt;/h2&gt;
&lt;h3&gt;L3 Heading&lt;/h3&gt;
&lt;h4&gt;L4 Heading&lt;/h4&gt;
&lt;h5&gt;L5 Heading&lt;/h5&gt;
&lt;h6&gt;L6 Heading&lt;/h6&gt;
&lt;h2&gt;Paragraph&lt;/h2&gt;
&lt;p&gt;We are creating a world that all may enter without privilege or prejudice accorded by race, economic power, military force, or station of birth.&lt;/p&gt;
&lt;p&gt;We are creating a world where anyone, anywhere may express his or her beliefs, no matter how singular, without fear of being coerced into silence or conformity.&lt;/p&gt;
&lt;h2&gt;Inline elements&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bold&lt;/strong&gt;, &lt;ruby&gt;Ruby&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;ルビ&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;, &lt;em&gt;Italic&lt;/em&gt;, &lt;del&gt;Strikethrough&lt;/del&gt;, &lt;a href="https://www.imalan.cn"&gt;Link&lt;/a&gt;&lt;sup id="fn_ref_1"&gt;&lt;a href="#fn_1"&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h2&gt;Blockquote and nested blockquote&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;安得广厦千万间，大庇天下寒士俱欢颜！风雨不动安如山。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;呜呼！何时眼前突兀见此屋，吾庐独破受冻死亦足！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;Inline code: &lt;code&gt;int a=1;&lt;/code&gt;. Code block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello World!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;List&lt;/h2&gt;
&lt;h3&gt;Unordered List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;iPhone&lt;ul&gt;
&lt;li&gt;iPhone X&lt;/li&gt;
&lt;li&gt;iPhone 11&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;iPad&lt;/li&gt;
&lt;li&gt;MacBook&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Ordered List&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;打开冰箱&lt;ol&gt;
&lt;li&gt;右手放在冰箱门拉手上&lt;/li&gt;
&lt;li&gt;左手扶住冰箱主体&lt;/li&gt;
&lt;li&gt;右手向后用力&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;把大象放进冰箱&lt;/li&gt;
&lt;li&gt;关上冰箱&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Horizontal rule&lt;/h2&gt;
&lt;hr&gt;
&lt;h2&gt;Math&lt;/h2&gt;
&lt;p&gt;Inline Math: $m\times n$, math block:&lt;/p&gt;
&lt;p&gt;$$C_{m\times k}=A_{m\times n}\cdot B_{n\times k}$$&lt;/p&gt;
&lt;h2&gt;Figures&lt;/h2&gt;
&lt;h3&gt;Single figure&lt;/h3&gt;
&lt;p&gt;&lt;figure style="flex: 92.88888888888889" &gt;&lt;img width="836" height="450" src="/Blog-With-GitHub-Boilerplate/archives/assets/e0affbc80ccb2d596c87b520e37e7071.jpg" /&gt;&lt;figcaption&gt;Princess Mononoke&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;Photoset&lt;/h3&gt;
&lt;div class="photos"&gt;
&lt;figure style="flex: 75.0" &gt;&lt;img width="4032" height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/4956a144888cdbbb6c2df1d1d15384b0.jpeg" /&gt;&lt;/figure&gt;
&lt;figure style="flex: 50.03720238095238" &gt;&lt;img width="2690" height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/4c66f0da616b08325b3aaa4c8b3f68e1.jpg" /&gt;&lt;/figure&gt;
&lt;figure style="flex: 75.0" &gt;&lt;img width="4032" height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/8b4d2334469ffa39b59e6fdb37c8c601.jpeg" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;div class="photos"&gt;
&lt;figure style="flex: 75.0" &gt;&lt;img width="4032" height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/0f5023d542a33e7c9d270f3cd6a99562.jpeg" /&gt;&lt;/figure&gt;
&lt;figure style="flex: 75.0" &gt;&lt;img width="4032" height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/20ec69d2a0276336f95e11f42866d17f.jpeg" /&gt;&lt;/figure&gt;
&lt;figure style="flex: 75.0" &gt;&lt;img width="4032" height="2688" src="/Blog-With-GitHub-Boilerplate/archives/assets/2b8af25285e5a193729a350593113bad.jpeg" /&gt;&lt;/figure&gt;&lt;/div&gt;&lt;h2&gt;Table&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;header&lt;/th&gt;
&lt;th&gt;header&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cell 1&lt;/td&gt;
&lt;td&gt;cell 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cell 3&lt;/td&gt;
&lt;td&gt;cell 4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Link Card&lt;/h2&gt;
&lt;div class="links"&gt;
&lt;a style="display:block" target="_blank" href="https://www.imalan.cn" class="board-item"&gt;                 &lt;div class="board-thumb"&gt;&lt;img src="https://secure.gravatar.com/avatar/1741a6eef5c824899e347e4afcbaa75d?s=200&amp;r=G&amp;d="&gt;&lt;/div&gt;                 &lt;div class="board-title"&gt;AlanDecode&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;&lt;hr&gt;&lt;div class="footnotes"&gt;&lt;ol&gt;&lt;li id="fn_1"&gt;Home page for AlanDecode &lt;a no-style href="#fn_ref_1"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><author>test@email.com (AlanDecode)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/typography/</guid><pubDate>Wed, 18 Dec 2019 16:50:00 +0806</pubDate></item><item><title>TCP半连接和全连接队列</title><link>/Blog-With-GitHub-Boilerplate/archives/TCP/</link><description>&lt;p&gt;原始文档为以下三篇，根据相关文档进行的整理。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://mp.weixin.qq.com/s/YpSlU1yaowTs-pF6R43hMw"&gt;从一次线上问题说起，详解 TCP 半连接队列、全连接队列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"&gt;TCP 半连接队列和全连接队列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.google.com/spreadsheets/d/1uz_1QSTsegHr6qqmq0PG1Y6c6RLFz5Y2FfkCma9jTkY/edit?usp=sharing"&gt;详解 TCP 半连接队列与全连接队列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，Linux 源码请看 &lt;a href="https://elixir.bootlin.com/linux/v3.10/source"&gt;https://elixir.bootlin.com/linux/v3.10/source&lt;/a&gt; ，可以快速跳转。&lt;/p&gt;
&lt;p&gt;全连接以及不开启cookie的半连接，Linux 3.10.0 的结果能分析出来，但是开了cookie的半连接，试验数据一直对不上。&lt;/p&gt;
&lt;p&gt;由于 C 语言 已经忘记了，C 语言源码分析是在引用链接结合 Chatgpt 进行分析理解的，部分实在分析不了，拾人牙慧。&lt;/p&gt;
&lt;h1&gt;1、基础信息&lt;/h1&gt;
&lt;h2&gt;1.1、服务端和客户端信息&lt;/h2&gt;
&lt;p&gt;本试验的 Linux 内核版本：3.10.0，以下均是基于此分析。&lt;/p&gt;
&lt;h2&gt;1.2、ss 命令&lt;/h2&gt;
&lt;p&gt;ss 利用到了 TCP 协议栈中的 tcp_diag（见 1.4 的分析）。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，这就确保了 ss 的快捷高效。当然，如果你的系统中没有 tcp_diag，ss 也可以正常运行，只是效率会变得稍慢。&lt;/p&gt;
&lt;p&gt;在「LISTEN 状态」时，&lt;code&gt;Recv-Q/Send-Q&lt;/code&gt; 表示的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 &lt;code&gt;accept()&lt;/code&gt; 的 TCP 连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Send-Q：当前全连接最大队列长度，下面的输出结果说明监听 8088 端口的 TCP 服务，最大全连接长度为 128；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -l , --listening 显示监听状态的套接字（sockets）&lt;/span&gt;
&lt;span class="c1"&gt;# -n , --numeric   不解析服务名称&lt;/span&gt;
&lt;span class="c1"&gt;# -t , --tcp       仅显示 TCP套接字（sockets）&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;ss&lt;span class="w"&gt; &lt;/span&gt;-lnt
State&lt;span class="w"&gt;       &lt;/span&gt;Recv-Q&lt;span class="w"&gt; &lt;/span&gt;Send-Q&lt;span class="w"&gt;            &lt;/span&gt;Local&lt;span class="w"&gt; &lt;/span&gt;Address:Port&lt;span class="w"&gt;                           &lt;/span&gt;Peer&lt;span class="w"&gt; &lt;/span&gt;Address:Port
LISTEN&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;::&lt;span class="o"&gt;]&lt;/span&gt;:8888&lt;span class="w"&gt;                                   &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;::&lt;span class="o"&gt;]&lt;/span&gt;:*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在「非 LISTEN 状态」时，&lt;code&gt;Recv-Q/Send-Q&lt;/code&gt; 表示的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Recv-Q：已收到但未被应用进程读取的字节数；&lt;/li&gt;
&lt;li&gt;Send-Q：已发送但未收到确认的字节数；&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -n , --numeric   不解析服务名称&lt;/span&gt;
&lt;span class="c1"&gt;# -t , --tcp       仅显示 TCP套接字（sockets）&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;ss&lt;span class="w"&gt; &lt;/span&gt;-nt
State&lt;span class="w"&gt;       &lt;/span&gt;Recv-Q&lt;span class="w"&gt; &lt;/span&gt;Send-Q&lt;span class="w"&gt;            &lt;/span&gt;Local&lt;span class="w"&gt; &lt;/span&gt;Address:Port&lt;span class="w"&gt;                           &lt;/span&gt;Peer&lt;span class="w"&gt; &lt;/span&gt;Address:Port
ESTAB&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;36&lt;/span&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.56.101:22&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.56.1:12656
CLOSE-WAIT&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;12&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;::ffff:192.168.56.101&lt;span class="o"&gt;]&lt;/span&gt;:8888&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;::ffff:192.168.56.100&lt;span class="o"&gt;]&lt;/span&gt;:34204
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3、netstat 命令&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;netstat -s&lt;/code&gt; 命令可以查看 TCP 半连接队列、全连接队列的溢出情况&lt;/p&gt;
&lt;p&gt;下面输出的数值是累计值，分别表示有多少 TCP socket 链接因为全连接队列、半连接队列满了而被丢弃&lt;/p&gt;
&lt;p&gt;注意 &lt;strong&gt;times&lt;/strong&gt; 是次数，不是时间的意思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在排查线上问题时，如果一段时间内相关数值一直在上升，则表明半连接队列、全连接队列有溢出情况&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;netstat&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;listen
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;911&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;times&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;the&lt;span class="w"&gt; &lt;/span&gt;listen&lt;span class="w"&gt; &lt;/span&gt;queue&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;socket&lt;span class="w"&gt; &lt;/span&gt;overflowed
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;911&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;SYNs&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;LISTEN&lt;span class="w"&gt; &lt;/span&gt;sockets&lt;span class="w"&gt; &lt;/span&gt;dropped
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.4、tcp_diag.c  分析&lt;/h2&gt;
&lt;p&gt;不同内核版本的 tcp_diag.c 的代码是不一样的，本试验的 Linux 内核版本：3.10.0&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ss&lt;/code&gt; 命令获取的 &lt;code&gt;Recv-Q/Send-Q&lt;/code&gt; 在「LISTEN 状态」和「非 LISTEN 状态」所表达的含义是不同的，见3.10.0的内核代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/tcp_diag.c&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;tcp_diag_get_info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;inet_diag_msg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcp_sk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_info&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 如果 TCP 连接状态是 LISTEN 时&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk_state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TCP_LISTEN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 当前全连接队列的大小&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idiag_rqueue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk_ack_backlog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 当前全连接的最大队列长度&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idiag_wqueue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk_max_ack_backlog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 如果 TCP 连接状态不是 LISTEN 时&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 已收到但未被应用进程读取的字节数&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idiag_rqueue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rcv_nxt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;copied_seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 已发送但未收到确认的字节数&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;idiag_wqueue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;write_seq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;snd_una&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;tcp_get_info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.5、Accept Queue：全连接队列的结论&lt;/h2&gt;
&lt;p&gt;Accept Queue：全连接队列&lt;/p&gt;
&lt;p&gt;最大队列为：&lt;code&gt;min(backlog, net.core.somaxconn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;校验 Accept Queue 是否满的逻辑如下（ 注意大于号才返回ture，即最终可存储 &lt;strong&gt;socket 数目会加1&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;return sk-&amp;gt;sk_ack_backlog &amp;gt; sk-&amp;gt;sk_max_ack_backlog&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;1.6、SYN Queue：半连接队列的结论&lt;/h2&gt;
&lt;p&gt;半连接的逻辑比较复杂，算出最大连接后，还有其他逻辑进行判断。实际测试下来的情况，不开启 cookie 的结果和结论能对的上，但是开启 cookie 后，测试的结果对不上【&lt;strong&gt;以后再进行分析，目前一直无法测试到结果&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不开启cookie的结论如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、半连接最大连接 &amp;gt; 0.75*tcp_max_syn_backlog，则 Drop SYN临界值为 0.75*tcp_max_syn_backlog +1【+1是因为判断条件是大于号，另外0.75乘法后的结果不确定是否是四舍五入还是向上取整，但是从实际结果来看小点数如果是 0.5 结果是按照 1 来计算】&lt;/p&gt;
&lt;p&gt;2、半连接最大连接 &amp;lt;= 0.75*tcp_max_syn_backlog，则 Drop SYN临界值为 半连接最大连接&lt;/p&gt;
&lt;p&gt;【tcp_v4_conn_request 函数的第三处判断，按照代码判断 等于号 应是上述 2 的结论，但是由于 测试中的 256除以0.75 不是整数，无法进一步确认等于号 =】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开启cookie的结论如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照网上说的，应是当半连接队列长度 &amp;gt; 全连接队列最大长度时，就会触发 DROP SYN 请求。但是目前我测试下来，SYN_RECV 的数量无法达到上限，无法验证结果。【&lt;strong&gt;后续再研究，目前测试一直无法得出啥结论&lt;/strong&gt;】&lt;/p&gt;
&lt;h3&gt;1.6.1、半连接队列最大长度控制&lt;/h3&gt;
&lt;p&gt;由于C语言已忘记，计算公式无法确认，以下信息为借鉴。&lt;/p&gt;
&lt;p&gt;很多博文中说半连接队列最大长度由 /proc/sys/net/ipv4/tcp_max_syn_backlog 参数指定，&lt;strong&gt;实际上只有在 linux 内核版本小于 2.6.20 时，半连接队列才等于 backlog 的大小&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// max_qlen_log - log_2 of maximal queued SYNs/REQUESTs&lt;/span&gt;
&lt;span class="c1"&gt;// 也就是说 最大半连接队列 等于 2 的 max_qlen_log 次方&lt;/span&gt;
&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;min_t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sysctl_max_syn_backlog&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;roundup_pow_of_two&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//向上取满足2的指数倍的整数&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lopt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_qlen_log&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lopt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_qlen_log&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;lopt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_qlen_log&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;//大体计算过程如下&lt;/span&gt;
&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;somaxconn&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;
&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sysctl_max_syn_backlog&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// roundup_pow_of_two: 将参数向上取整到最小的 2^n&lt;/span&gt;
&lt;span class="c1"&gt;// 注意这里存在一个 +1&lt;/span&gt;
&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;roundup_pow_of_two&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;max_qlen_log&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;max_queue_length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;max_qlen_log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sysctl_max_syn_backlog 即内核参数 net.ipv4.tcp_max_syn_backlog （3.10.0 代码默认值是256，但是系统参数是128）&lt;/p&gt;
&lt;p&gt;2^max_qlen_log^ 也就是最大情况为 2^log2{nr_table_entries}^ ,也就是 nr_table_entries 的值；最小为 8&lt;/p&gt;
&lt;p&gt;有一点绕，不过运算都很简单，半连接队列的长度实际上由三个参数决定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt; 时传入的 backlog&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc/sys/net/ipv4/tcp_max_syn_backlog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc/sys/net/core/somaxconn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 相关操作命令&lt;/span&gt;
&lt;span class="c1"&gt;# backlog，用的 Golang 测试，在 Golang 中，listen 的 backlog 参数使用的是 /proc/sys/net/core/somaxconn 文档中的值&lt;/span&gt;
sudo&lt;span class="w"&gt; &lt;/span&gt;sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.core.somaxconn&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;
sudo&lt;span class="w"&gt; &lt;/span&gt;sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_max_syn_backlog&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;512&lt;/span&gt;
sudo&lt;span class="w"&gt; &lt;/span&gt;sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_syncookies&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.6.2、判断是否 Drop SYN 请求&lt;/h3&gt;
&lt;p&gt;当 Client 端向 Server 端发送 SYN 报文后，Server 端会将该 socket 连接存储到半连接队列(SYN Queue)，如果 Server 端判断半连接队列满了则会将连接 Drop 丢弃。&lt;/p&gt;
&lt;p&gt;那么 Server 端是如何判断半连接队列是否满的呢？除了上面一小节提到的半连接队列最大长度控制外，还和 /proc/sys/net/ipv4/tcp_syncookies 参数有关。(tcp_syncookies 的作用是为了防止 SYN Flood 攻击的)&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 56.20031796502385" &gt;&lt;img width="707" height="629" src="https://raw.githubusercontent.com/iYangcw/Photo/master/sys_length_calc.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：第一个判断条件 「当前半连接队列是否已超过半连接队列最大长度」在不同内核版本中的判断不一样，引用文章的 Linux 4.19.91 内核判断的是当前半连接队列长度是否 &amp;gt;= 全连接队列最大长度，但是本文实验的 Linux 3.10.0 正好满足该截图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际测试的结果如下，按照cookie是否开启进行测试验证。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.google.com/spreadsheets/d/1uz_1QSTsegHr6qqmq0PG1Y6c6RLFz5Y2FfkCma9jTkY/edit?usp=sharing"&gt;Google 表格链接&lt;/a&gt; ：Sheet里面已经写好了部分计算公式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没开启cookie的结果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux 3.10.0 的测试结果如下：&lt;/p&gt;
&lt;p&gt;字段 a = max(min(backlog,somaxconn,sysctl_max_sys_backlog),8)&lt;/p&gt;
&lt;p&gt;半队列最大长度等于 &lt;code&gt;roundup_pow_of_two(a+1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于是 &lt;code&gt;Golang&lt;/code&gt; 测试，backlog 等于 somaxconn&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;somaxconn&lt;/th&gt;
&lt;th&gt;tcp_max_syn_backlog&lt;/th&gt;
&lt;th&gt;tcp_max_syn_backlog * 0.75&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;半队列Max&lt;/th&gt;
&lt;th&gt;全队列Max&lt;/th&gt;
&lt;th&gt;Drop SYN 临界值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;96+1=97&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;118&lt;/td&gt;
&lt;td&gt;88.5&lt;/td&gt;
&lt;td&gt;118&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;88.5+1=90&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;108&lt;/td&gt;
&lt;td&gt;81&lt;/td&gt;
&lt;td&gt;108&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;81+1=82&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1.5&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1.5+1=3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;384&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;342&lt;/td&gt;
&lt;td&gt;256.5&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;340&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;255+1=256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;338&lt;/td&gt;
&lt;td&gt;253.5&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;253.5+1=255&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;实验一：syncookies&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;，somaxconn&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;，backlog&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;，tcp_max_syn_backlog&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;
计算出的半连接队列最大长度为&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;256&lt;/span&gt;
当半连接队列长度增长至&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;96&lt;/span&gt;+1&lt;span class="w"&gt; &lt;/span&gt;后，后续&lt;span class="w"&gt; &lt;/span&gt;SYN&lt;span class="w"&gt; &lt;/span&gt;请求就会触发&lt;span class="w"&gt; &lt;/span&gt;Drop
&lt;span class="c1"&gt;# 客户端进行压测&lt;/span&gt;
hping3&lt;span class="w"&gt; &lt;/span&gt;-S&lt;span class="w"&gt; &lt;/span&gt;-p&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;8888&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;--flood&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.56.101
&lt;span class="c1"&gt;# 服务端每秒获取 SYN_RECV 连接数，结果稳定在 97&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;netstat&lt;span class="w"&gt; &lt;/span&gt;-nat&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;:8888&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;SYN_RECV&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;wc&lt;span class="w"&gt; &lt;/span&gt;-l&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;sleep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;ss&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;state&lt;span class="w"&gt; &lt;/span&gt;syn-recv&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;sport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;:8888&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;wc&lt;span class="w"&gt; &lt;/span&gt;-l&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;sleep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;done&lt;/span&gt;

其他的参数试验见表格结果。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;开启cookie的结果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一直无法复现网上结果，待定！&lt;/p&gt;
&lt;h2&gt;1.7、tcp_v4_conn_request 源码&lt;/h2&gt;
&lt;p&gt;内核版本：3.10.0&lt;/p&gt;
&lt;p&gt;TCP 第一次握手：收到 SYN 包 的 Linux 内核代码如下，下文缩减了大量代码，只保留了 TCP 办连接队列溢出的处理逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半连接队列满了，且 isn 为 0，且没有开启 tcp_syncookies，则丢弃连接&lt;/li&gt;
&lt;li&gt;全连接队列满了，且没有重传的包的连接请求多余1个，则会丢弃&lt;/li&gt;
&lt;li&gt;禁用SYN Cookie机制，并且队列中剩余的连接请求数量小于最大队列长度的四分之一，同时&lt;code&gt;tcp_peer_is_proven&lt;/code&gt;函数返回&lt;code&gt;false&lt;/code&gt;（表明当前目标端无法被证明是存活的），那么连接请求将被拒绝并释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/tcp_ipv4.c&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;tcp_v4_conn_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sk_buff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_options_received&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp_opt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;request_sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;inet_request_sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ireq&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcp_sk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;dst_entry&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;__be32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ip_hdr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;__be32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;daddr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ip_hdr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;daddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;__u32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TCP_SKB_CB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;when&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;want_cookie&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;flowi4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fl4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_fastopen_cookie&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_fastopen_cookie&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;valid_foc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sk_buff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;skb_synack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;do_fastopen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* TW buckets are converted to open requests without&lt;/span&gt;
&lt;span class="cm"&gt;     * limitations, they conserve resources and peer is&lt;/span&gt;
&lt;span class="cm"&gt;     * evidently real one.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 1、半连接队列满了，且 isn 为 0，且没有开启 tcp_syncookies，则丢弃连接&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inet_csk_reqsk_queue_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;want_cookie&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcp_syn_flood_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;TCP&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;want_cookie&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;goto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Accept backlog is full. If we have already queued enough&lt;/span&gt;
&lt;span class="cm"&gt;     * of warm entries in syn queue, drop request. It is better than&lt;/span&gt;
&lt;span class="cm"&gt;     * clogging syn queue with openreqs with exponentially increasing&lt;/span&gt;
&lt;span class="cm"&gt;     * timeout.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 若此时 accept queue 也已满，并且 qlen_young 的值大于 1（即保存在 SYN queue 中未进行 SYN,ACK 重传的连接超过 1 个）&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 则直接丢弃当前 SYN 包（相当于针对 SYN 进行了速率限制）&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk_acceptq_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inet_csk_reqsk_queue_young&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NET_INC_STATS_BH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock_net&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_MIB_LISTENOVERFLOWS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;goto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// 大体意思就是开启了 sysctl_tcp_syncookies ，则 want_cookie 为 true   &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;want_cookie&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cookie_v4_init_sequence&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cookie_ts&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp_opt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tstamp_ok&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* VJ&amp;#39;s idea. We save last timestamp seen&lt;/span&gt;
&lt;span class="cm"&gt;         * from the destination in peer table, when entering&lt;/span&gt;
&lt;span class="cm"&gt;         * state TIME-WAIT, and check against it before&lt;/span&gt;
&lt;span class="cm"&gt;         * accepting new connection request.&lt;/span&gt;
&lt;span class="cm"&gt;         *&lt;/span&gt;
&lt;span class="cm"&gt;         * If &amp;quot;isn&amp;quot; is not zero, this request hit alive&lt;/span&gt;
&lt;span class="cm"&gt;         * timewait bucket, so that all the necessary checks&lt;/span&gt;
&lt;span class="cm"&gt;         * are made in the function processing timewait state.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_opt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;saw_tstamp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;tcp_death_row&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sysctl_tw_recycle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inet_csk_route_req&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fl4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;fl4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;daddr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;tcp_peer_is_proven&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;NET_INC_STATS_BH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock_net&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_MIB_PAWSPASSIVEREJECTED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;goto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop_and_release&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* Kill the following clause, if you dislike this way. */&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 3--不开启cookie的情况，inet_csk_reqsk_queue_len为当前队列大小&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;sysctl_tcp_syncookies&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sysctl_max_syn_backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inet_csk_reqsk_queue_len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sysctl_max_syn_backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;tcp_peer_is_proven&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* Without syncookies last quarter of&lt;/span&gt;
&lt;span class="cm"&gt;             * backlog is filled with destinations,&lt;/span&gt;
&lt;span class="cm"&gt;             * proven to be alive.&lt;/span&gt;
&lt;span class="cm"&gt;             * It means that we continue to communicate&lt;/span&gt;
&lt;span class="cm"&gt;             * to destinations, already remembered&lt;/span&gt;
&lt;span class="cm"&gt;             * to the moment of synflood.&lt;/span&gt;
&lt;span class="cm"&gt;             */&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;LIMIT_NETDEBUG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_DEBUG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pr_fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;drop open request from %pI4/%u&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_hdr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;goto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop_and_release&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcp_v4_init_sequence&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;tcp_rsk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;snt_isn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.8、SYN 和 ACCEPT 连接图&lt;/h2&gt;
&lt;p&gt;&lt;figure style="flex: 50.709219858156025" &gt;&lt;img width="1144" height="1128" src="https://raw.githubusercontent.com/iYangcw/Photo/master/SYN%20Queue%20and%20Accept%20Queue.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;连接创建时，客户端通过发送&lt;code&gt;SYN&lt;/code&gt;报文发起向处于监听状态的服务器发起连接，服务器为该连接分配一定的资源，并发送&lt;code&gt;SYN+ACK&lt;/code&gt;报文。对服务器来说，此时该连接的状态称为&lt;code&gt;半连接&lt;/code&gt;(&lt;code&gt;Half-Open&lt;/code&gt;)，而当其之后收到客户端回复的&lt;code&gt;ACK&lt;/code&gt;报文后，连接才算创建完成。在这个过程中，如果服务器一直没有收到&lt;code&gt;ACK&lt;/code&gt;报文(比如在链路中丢失了)，服务器会在超时后重传&lt;code&gt;SYN+ACK&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;2、全连接队列实战&lt;/h1&gt;
&lt;h2&gt;2.1、结论&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（准确点说应该是根据内核版本来确认代码里面的判断逻辑，目前暂时认为所有 Linux 的版本都是上面的结论）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;somaxconn&lt;/code&gt; 是 Linux 内核的参数，可以通过 &lt;code&gt;/proc/sys/net/core/somaxconn&lt;/code&gt; 来设置其值，默认值根据版本来，是128 或者 4096。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# https://man7.org/linux/man-pages/man2/listen.2.html&lt;/span&gt;
Since&lt;span class="w"&gt; &lt;/span&gt;Linux&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;.4,&lt;span class="w"&gt; &lt;/span&gt;the&lt;span class="w"&gt; &lt;/span&gt;default&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;this&lt;span class="w"&gt; &lt;/span&gt;file&lt;span class="w"&gt; &lt;/span&gt;is&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;earlier&lt;span class="w"&gt; &lt;/span&gt;kernels,&lt;span class="w"&gt; &lt;/span&gt;the&lt;span class="w"&gt; &lt;/span&gt;default&lt;span class="w"&gt; &lt;/span&gt;value&lt;span class="w"&gt; &lt;/span&gt;is&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;.&lt;span class="w"&gt;  &lt;/span&gt;In&lt;span class="w"&gt; &lt;/span&gt;kernels&lt;span class="w"&gt; &lt;/span&gt;before
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.4.25,&lt;span class="w"&gt; &lt;/span&gt;this&lt;span class="w"&gt; &lt;/span&gt;limit&lt;span class="w"&gt; &lt;/span&gt;was&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;hard&lt;span class="w"&gt; &lt;/span&gt;coded&lt;span class="w"&gt; &lt;/span&gt;value,&lt;span class="w"&gt; &lt;/span&gt;SOMAXCONN,&lt;span class="w"&gt; &lt;/span&gt;with&lt;span class="w"&gt; &lt;/span&gt;the
&lt;span class="w"&gt;       &lt;/span&gt;value&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;backlog&lt;/code&gt; 是 &lt;code&gt;listen(int sockfd, int backlog)&lt;/code&gt; 函数中的 backlog 大小&lt;/p&gt;
&lt;p&gt;&amp;lt;Unix 网络编程&amp;gt;将其描述为&lt;strong&gt;已完成的连接队列&lt;/strong&gt;(&lt;code&gt;ESTABLISHED&lt;/code&gt;)与&lt;strong&gt;未完成连接队列&lt;/strong&gt;(&lt;code&gt;SYN_RCVD&lt;/code&gt;)之和的上限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// https://elixir.bootlin.com/linux/v3.10/source/net/socket.c&lt;/span&gt;
&lt;span class="n"&gt;SYSCALL_DEFINE2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;socket&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fput_needed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;somaxconn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sockfd_lookup_light&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fput_needed&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;somaxconn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sock_net&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sysctl_somaxconn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;somaxconn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;somaxconn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;security_socket_listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;fput_light&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fput_needed&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2、测试方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;strong&gt;wrk&lt;/strong&gt; 对服务端的 &lt;strong&gt;nginx&lt;/strong&gt; 发起压测来查看当前队列 &lt;strong&gt;Recv-Q&lt;/strong&gt; 使用情况&lt;/li&gt;
&lt;li&gt;通过 &lt;strong&gt;go&lt;/strong&gt; 代码发起 &lt;strong&gt;http&lt;/strong&gt; 请求：只负责 Listen 对应端口，而不执行 accept() TCP 连接，使TCP全连接队列溢出，抓包进行分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.3、wrk 操作过程&lt;/h2&gt;
&lt;p&gt;系统参数配置信息如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# nginx 配置文件的backlog，默认为511，另外如果修改的话，nginx需要重启，reload 看下来 backlog 是不生效的&lt;/span&gt;
&lt;span class="nv"&gt;backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;511&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.core.somaxconn&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;
&lt;span class="c1"&gt;# cookies 开启关闭都测试下&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_syncookies&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_syncookies&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="c1"&gt;# net.ipv4.tcp_max_syn_backlog=512 默认值，没有修改&lt;/span&gt;
&lt;span class="c1"&gt;# tcp_max_syn_backlog 不动，3.10 内核上默认是 512，backlog 和 max_syn_backlog 应该是有一定关系的，应该不能超过 max_syn_backlog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动 nginx 服务后，通过 ss 确认 Send-Q 大小（按照 min(128,511) 原则，应是 128）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# nginx 的端口为 80&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;ss&lt;span class="w"&gt; &lt;/span&gt;-lnt
State&lt;span class="w"&gt;       &lt;/span&gt;Recv-Q&lt;span class="w"&gt; &lt;/span&gt;Send-Q&lt;span class="w"&gt;            &lt;/span&gt;Local&lt;span class="w"&gt; &lt;/span&gt;Address:Port&lt;span class="w"&gt;                           &lt;/span&gt;Peer&lt;span class="w"&gt; &lt;/span&gt;Address:Port
LISTEN&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;&lt;span class="w"&gt;                           &lt;/span&gt;*:80&lt;span class="w"&gt;                                        &lt;/span&gt;*:*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端压测过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 客户端发起 wrk 压测&lt;/span&gt;
&lt;span class="c1"&gt;# -t 20     表示 20 个线程（建议调大，否则有可能服务端能处理过来，Recv-Q 不会超标）&lt;/span&gt;
&lt;span class="c1"&gt;# -c 30000  表示 3 万个连接&lt;/span&gt;
&lt;span class="c1"&gt;# -d 60s    表示持续压测 60 秒&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1000000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;# 临时调大点，否则有可能提示 Too many open files&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;wrk&lt;span class="w"&gt; &lt;/span&gt;-t&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;30000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;60s&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:80
Running&lt;span class="w"&gt; &lt;/span&gt;1m&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;@&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:80
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;threads&lt;span class="w"&gt; &lt;/span&gt;and&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;30000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;connections
&lt;span class="w"&gt;  &lt;/span&gt;Thread&lt;span class="w"&gt; &lt;/span&gt;Stats&lt;span class="w"&gt;   &lt;/span&gt;Avg&lt;span class="w"&gt;      &lt;/span&gt;Stdev&lt;span class="w"&gt;     &lt;/span&gt;Max&lt;span class="w"&gt;   &lt;/span&gt;+/-&lt;span class="w"&gt; &lt;/span&gt;Stdev
&lt;span class="w"&gt;    &lt;/span&gt;Latency&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;278&lt;/span&gt;.14ms&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;197&lt;/span&gt;.13ms&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.99s&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;83&lt;/span&gt;.94%
&lt;span class="w"&gt;    &lt;/span&gt;Req/Sec&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;131&lt;/span&gt;.67&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;207&lt;/span&gt;.18&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.68k&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;90&lt;/span&gt;.59%
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;43677&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;requests&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.01m,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;55&lt;/span&gt;.90MB&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;read&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;Socket&lt;span class="w"&gt; &lt;/span&gt;errors:&lt;span class="w"&gt; &lt;/span&gt;connect&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;read&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1022705&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;write&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;timeout&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1369&lt;/span&gt;
Requests/sec:&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;722&lt;/span&gt;.80
Transfer/sec:&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.93MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务端相关信息：&lt;code&gt;tcp_syncookies&lt;/code&gt; 关闭，发现 Recv-Q 很快就到达 &lt;strong&gt;129&lt;/strong&gt;，且几乎持续维持在这个值；反之如果开启了，Recv-Q 也达到过 &lt;strong&gt;129&lt;/strong&gt;，但是波动很大。从常识上也能理解到开启 cookie 了有存在复用，所以当前连接队列会小一点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 间隔一秒，定时检测 80 端口的 socket 连接信息&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;当前时间:&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date&lt;span class="w"&gt; &lt;/span&gt;+%T&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;ss&lt;span class="w"&gt; &lt;/span&gt;-lnt&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;-E&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Send-Q|80&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;sleep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;done&lt;/span&gt;
当前时间:05:23:55
State&lt;span class="w"&gt;      &lt;/span&gt;Recv-Q&lt;span class="w"&gt; &lt;/span&gt;Send-Q&lt;span class="w"&gt; &lt;/span&gt;Local&lt;span class="w"&gt; &lt;/span&gt;Address:Port&lt;span class="w"&gt;               &lt;/span&gt;Peer&lt;span class="w"&gt; &lt;/span&gt;Address:Port&lt;span class="w"&gt;              &lt;/span&gt;
LISTEN&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;61&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;*:80&lt;span class="w"&gt;                       &lt;/span&gt;*:*&lt;span class="w"&gt;                  &lt;/span&gt;
当前时间:05:23:56
State&lt;span class="w"&gt;      &lt;/span&gt;Recv-Q&lt;span class="w"&gt; &lt;/span&gt;Send-Q&lt;span class="w"&gt; &lt;/span&gt;Local&lt;span class="w"&gt; &lt;/span&gt;Address:Port&lt;span class="w"&gt;               &lt;/span&gt;Peer&lt;span class="w"&gt; &lt;/span&gt;Address:Port&lt;span class="w"&gt;              &lt;/span&gt;
LISTEN&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;129&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;128&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;*:80&lt;span class="w"&gt;                       &lt;/span&gt;*:*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;且注意下，Recv-Q 的最大值就是 【全连接队列最大值 + 1】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该现象是因为&lt;strong&gt;内核在判断全连接是否满&lt;/strong&gt;的情况下，使用的是 &amp;gt; 而非 &amp;gt;= 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// https://github.com/torvalds/linux/blob/v3.10/include/net/sock.h&lt;/span&gt;
&lt;span class="c1"&gt;// 检测全连接队列是否已满的函数&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sk_acceptq_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// sk_ack_backlog：当前全连接队列的大小&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// sk_max_ack_backlog：当前全连接的最大队列长度&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk_ack_backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk_max_ack_backlog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接&lt;/strong&gt;，丢掉的 TCP 连接的个数会被统计起来，我们可以使用 netstat -s 命令来查看：注意下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;netstat&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;listen
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;180233&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;times&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;the&lt;span class="w"&gt; &lt;/span&gt;listen&lt;span class="w"&gt; &lt;/span&gt;queue&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;socket&lt;span class="w"&gt; &lt;/span&gt;overflowed
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;594579&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;SYNs&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;LISTEN&lt;span class="w"&gt; &lt;/span&gt;sockets&lt;span class="w"&gt; &lt;/span&gt;dropped
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.4、go 抓包操作过程&lt;/h2&gt;
&lt;h3&gt;2.4.1、go 代码&lt;/h3&gt;
&lt;p&gt;为了方便实验，将 &lt;strong&gt;server&lt;/strong&gt; 端的 &lt;strong&gt;somaxconn&lt;/strong&gt; 全连接队列最大长度更新为 5，另外启动 go 服务后请通过 ss -lnt 确认是否生效&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo sysctl -w net.core.somaxconn=128&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ss -lnt |grep -E 'Send-Q|8888'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;server 端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 只负责 Listen 对应端口而不执行 accept() TCP 连接&lt;/span&gt;
&lt;span class="c1"&gt;// server.go&lt;/span&gt;
&lt;span class="c1"&gt;// go build server.go&lt;/span&gt;
&lt;span class="c1"&gt;// ./server&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;log&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;net&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tcp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;:8888&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;failed to listen due to %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;defer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;l&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;listen :8888 success&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client 代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// client 端并发请求 10 次 server 端，成功创建 tcp 连接后向 server 端发送数据&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;context&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;log&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;net&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;os&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;os/signal&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sync&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;syscall&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;time&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WaitGroup&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;establishConn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;defer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DialTimeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tcp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;192.168.56.101:8888&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d, dial error: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d, dial success&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="nb"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d, send error: %v&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Done&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d, dail close&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cancel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WithCancel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Background&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;wg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;go&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;establishConn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;go&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;sc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Signal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;syscall&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;SIGINT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nx"&gt;cancel&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.4.2、操作过程&lt;/h3&gt;
&lt;p&gt;服务端启动程序后，客户端按照以下命令开始抓包后，再执行客户端程序&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo  tshark -Eheader=y -l -f "tcp port 8888" -i any -w client_to_server.pcap&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;2.4.3、抓包结果分析&lt;/h3&gt;
&lt;p&gt;第三步的抓包结果不是每次必现&lt;/p&gt;
&lt;h3&gt;2.4.4、抓包结果-01&lt;/h3&gt;
&lt;p&gt;正常连接&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 415.0900900900901" &gt;&lt;img width="1843" height="222" src="https://raw.githubusercontent.com/iYangcw/Photo/master/connect_01.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;2.4.5、抓包结果-02&lt;/h3&gt;
&lt;p&gt;&lt;figure style="flex: 146.03053435114504" &gt;&lt;img width="1913" height="655" src="https://raw.githubusercontent.com/iYangcw/Photo/master/connect_02.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Client 认为成功与 Server 端创建 tcp socket 连接，后续发送数据失败，持续 RETRY;Server 端认为 TCP 连接未创建，一直在发送SYN+ACK。&lt;/p&gt;
&lt;p&gt;Server 端为什么一直在 RETRY 发送 &lt;code&gt;SYN+ACK&lt;/code&gt;? Server 端不是已经收到了 Client 端的 ACK 确认了吗?&lt;/p&gt;
&lt;p&gt;上述情况是由于 Server 端 socket 连接进入了半连接队列，在收到 Client 端 ACK 后，本应将 socket 连接存储到全连接队列，但是全连接队列已满，所以 Server 端 DROP 了该 ACK 请求。&lt;/p&gt;
&lt;p&gt;Server 端一直在 RETRY 发送 &lt;code&gt;SYN+ACK&lt;/code&gt;，是因为 DROP 了 client 端的 ACK 请求，所以 socket 连接仍旧在半连接队列中，等待 Client 端回复 ACK。&lt;/p&gt;
&lt;p&gt;全连接队列满 DROP 请求是默认行为，可以通过设置 &lt;code&gt;/proc/sys/net/ipv4/tcp_abort_on_overflow&lt;/code&gt; 使 Server 端在全连接队列满时，向 Client 端发送 RST 报文。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tcp_abort_on_overflow&lt;/code&gt; 有两种可选值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：如果全连接队列满了，Server 端 DROP Client 端回复的 ACK 【默认值】&lt;/li&gt;
&lt;li&gt;1：如果全连接队列满了，Server 端向 Client 端发送 RST 报文，终止 TCP socket 链接&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.4.6、抓包结果-03&lt;/h3&gt;
&lt;p&gt;&lt;figure style="flex: 447.4299065420561" &gt;&lt;img width="1915" height="214" src="https://raw.githubusercontent.com/iYangcw/Photo/master/connect_03.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Client 向 Server 发送 SYN 未得到相应，一直在 RETRY。&lt;/p&gt;
&lt;p&gt;需要结合半连接队列来分析，结论如下&lt;/p&gt;
&lt;p&gt;1、开启了 &lt;code&gt;/proc/sys/net/ipv4/tcp_syncookies&lt;/code&gt; 功能&lt;/p&gt;
&lt;p&gt;2、全连接队列满了&lt;/p&gt;
&lt;h1&gt;3、半连接队列实战&lt;/h1&gt;
&lt;h2&gt;3.1、结论&lt;/h2&gt;
&lt;p&gt;见 1.6 结论&lt;/p&gt;
&lt;h2&gt;3.2、内核代码分析&lt;/h2&gt;
&lt;p&gt;见1.7&lt;/p&gt;
&lt;h3&gt;3.2.1、半连接代码&lt;/h3&gt;
&lt;p&gt;代码流程大致流程就是：&lt;/p&gt;
&lt;p&gt;半连接队列满了，且 ISN 为0，则判断是否开启 cookie，如果开启了cookie 走其他逻辑，如果没开启cookie，则丢弃该包&lt;/p&gt;
&lt;p&gt;大白话，个人理解如下（SYN洪水攻击的逻辑）：&lt;/p&gt;
&lt;p&gt;这一部分应该是 SYN 洪水攻击避免的实现逻辑，SYN洪水攻击中，攻击者通常会将TCP握手过程中的调用方序列号（ISN）置为0，目的在于混淆目标主机，并使其无法正确地处理TCP连接请求。&lt;/p&gt;
&lt;p&gt;所以方法的逻辑是 &lt;code&gt;!isn&lt;/code&gt;，如果队列已满，且有 ISN=0 的情况，则走到 want_cookie 的逻辑；&lt;/p&gt;
&lt;p&gt;如果不需要进行 cookie 验证，则直接跳转到 drop，即丢弃该数据包。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 半连接队列满了，且 isn 为 0：即没有生成初始序列号&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inet_csk_reqsk_queue_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;want_cookie&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcp_syn_flood_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;TCP&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;want_cookie&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;goto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;    第一处分析&lt;/span&gt;
&lt;span class="cm"&gt;    https://elixir.bootlin.com/linux/v3.10/source/include/net/inet_connection_sock.h#L297&lt;/span&gt;
&lt;span class="cm"&gt;    该函数主要通过调用reqsk_queue_is_full函数来判断TCP套接字的请求队列是否已满，函数输入参数为TCP套接字sk.&lt;/span&gt;
&lt;span class="cm"&gt;    在函数实现中，首先调用inet_csk函数获取TCP套接字的传输控制块，并通过icsk_accept_queue访问请求队列，从而判断该请求队列是否已满.&lt;/span&gt;
&lt;span class="cm"&gt;    队列已满,函数  返回 1;&lt;/span&gt;
&lt;span class="cm"&gt;    队列未满,函数  返回 0.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inet_csk_reqsk_queue_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reqsk_queue_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;inet_csk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;icsk_accept_queue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reqsk_queue_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;request_sock_queue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     C语言不懂，查阅资料说是这段代码的意思是&lt;/span&gt;
&lt;span class="cm"&gt;     用于检查一个请求队列是否已满。该函数的作用是判断指定的请求队列是否已经达到了最大队列长度，如果达到最大长度则返回1，否则返回0。&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;listen_opt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;qlen&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;listen_opt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;max_qlen_log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;    第二处分析：!isn，能正常往该函数继续往下走，也就是 isn 为 0&lt;/span&gt;
&lt;span class="cm"&gt;    一个TCP连接的ISN被设置为0，这意味着这个连接没有已知的初始序列号。这意味着发送方和接收方都将从初始位置开始传输数据。&lt;/span&gt;

&lt;span class="cm"&gt;    __u32 isn = TCP_SKB_CB(skb)-&amp;gt;when;&lt;/span&gt;
&lt;span class="cm"&gt;    这段代码是从skb中获取TCP协议块的发送时间戳，并将其赋值给变量isn。&lt;/span&gt;

&lt;span class="cm"&gt;    __u32：unsigned 32-bit integer（无符号32位整数）&lt;/span&gt;
&lt;span class="cm"&gt;    TCP_SKB_CB(skb)是一个宏定义，用于获取指向TCP协议块头部的指针，这里使用when字段来表示该TCP协议块的发送时间戳。&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;


&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;    第三处分析：tcp_syn_flood_action&lt;/span&gt;
&lt;span class="cm"&gt;    https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/tcp_ipv4.c&lt;/span&gt;
&lt;span class="cm"&gt;    Return true if a syncookie should be sent&lt;/span&gt;
&lt;span class="cm"&gt;    大体意思就是开启了 sysctl_tcp_syncookies ，则 want_cookie 为 true&lt;/span&gt;
&lt;span class="cm"&gt;    这个参数默认值为1，可以通过修改 /proc/sys/net/ipv4/tcp_syncookies 文件或者使用sysctl命令进行修改&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2.2、全连接代码&lt;/h3&gt;
&lt;p&gt;若此时 accept queue 也已满，并且 qlen_young 的值大于 1（即保存在 SYN queue 中未进行 SYN,ACK 重传的连接超过 1 个），则直接丢弃当前 SYN 包（相当于针对 SYN 进行了速率限制）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk_acceptq_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inet_csk_reqsk_queue_young&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NET_INC_STATS_BH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sock_net&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_MIB_LISTENOVERFLOWS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;goto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一处代码分析如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;    https://elixir.bootlin.com/linux/v3.10/source/include/net/sock.h#L723&lt;/span&gt;
&lt;span class="cm"&gt;    如果TCP连接请求接收队列已满，则返回true。&lt;/span&gt;
&lt;span class="cm"&gt;    通过检查 backlog 和 sk_max_ack_backlog 字段的值，来决定TCP连接请求队列是否已满。&lt;/span&gt;
&lt;span class="cm"&gt;    sk_ack_backlog  当前全连接队列大小&lt;/span&gt;
&lt;span class="cm"&gt;    sk_max_ack_backlog  全连接队列最大值 min(somaxconn,backlog)&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sk_acceptq_is_full&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk_ack_backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk_max_ack_backlog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二处代码分析如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;    https://elixir.bootlin.com/linux/v3.10/source/include/net/inet_connection_sock.h#L292&lt;/span&gt;
&lt;span class="cm"&gt;    看的不是很明白，qlen_young 没理解意思，机械理解成 保存在 SYN queue 中未进行 SYN,ACK 重传的连接&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;inet_csk_reqsk_queue_young&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reqsk_queue_len_young&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;inet_csk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;icsk_accept_queue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// https://elixir.bootlin.com/linux/v3.10/source/include/net/request_sock.h#L252&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;reqsk_queue_len_young&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;request_sock_queue&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;listen_opt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;qlen_young&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/** struct listen_sock - listen state&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * @max_qlen_log - log_2 of maximal queued SYNs/REQUESTs&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;listen_sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u8&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;max_qlen_log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u8&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;synflood_warned&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 2 bytes hole, try to use */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;qlen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;qlen_young&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;clock_hand&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;hash_rnd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;nr_table_entries&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;request_sock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;syn_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3.3、请求队列溢出时的逻辑&lt;/h3&gt;
&lt;p&gt;代码展示了Linux内核中在TCP连接请求队列溢出时的逻辑&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;sysctl_tcp_syncookies&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sysctl_max_syn_backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inet_csk_reqsk_queue_len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sysctl_max_syn_backlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;tcp_peer_is_proven&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* Without syncookies last quarter of&lt;/span&gt;
&lt;span class="cm"&gt;             * backlog is filled with destinations,&lt;/span&gt;
&lt;span class="cm"&gt;             * proven to be alive.&lt;/span&gt;
&lt;span class="cm"&gt;             * It means that we continue to communicate&lt;/span&gt;
&lt;span class="cm"&gt;             * to destinations, already remembered&lt;/span&gt;
&lt;span class="cm"&gt;             * to the moment of synflood.&lt;/span&gt;
&lt;span class="cm"&gt;             */&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;LIMIT_NETDEBUG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_DEBUG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pr_fmt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;drop open request from %pI4/%u&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp_hdr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;goto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;drop_and_release&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;4、参考文档&lt;/h1&gt;
&lt;p&gt;从一次线上问题说起，详解 TCP 半连接队列、全连接队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/YpSlU1yaowTs-pF6R43hMw"&gt;https://mp.weixin.qq.com/s/YpSlU1yaowTs-pF6R43hMw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;深入浅出TCP中的SYN-Cookies&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://segmentfault.com/a/1190000019292140"&gt;https://segmentfault.com/a/1190000019292140&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP 半连接队列和全连接队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"&gt;https://xiaolincoding.com/network/3_tcp/tcp_queue.html#%E4%BB%80%E4%B9%88%E6%98%AF-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详解 TCP 半连接队列与全连接队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/"&gt;https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 Linux 源码看 Socket (TCP) 的 listen 及连接队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://my.oschina.net/alchemystar/blog/4672630"&gt;https://my.oschina.net/alchemystar/blog/4672630&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详解 TCP 半连接队列与全连接队列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/"&gt;https://wgzhao.github.io/notes/troubleshooting/deep-in-tcp-connect/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[内核源码] 网络协议栈 - listen (tcp)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wenfh2020.com/2021/07/21/kernel-sys-listen/"&gt;https://wenfh2020.com/2021/07/21/kernel-sys-listen/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;socket API 实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.guorongfei.com/tags/socket/"&gt;http://blog.guorongfei.com/tags/socket/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SYN packet handling in the wild&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.cloudflare.com/syn-packet-handling-in-the-wild/"&gt;https://blog.cloudflare.com/syn-packet-handling-in-the-wild/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><author>test@email.com (Sai)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/TCP/</guid><pubDate>Tue, 28 Mar 2023 14:50:00 +0806</pubDate></item><item><title>TCP发送窗口、接收窗口、wmem、rmem 关系</title><link>/Blog-With-GitHub-Boilerplate/archives/TCP发送窗口、接收窗口、wmem、rmem 关系/</link><description>&lt;h1&gt;基础环境&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;服务器信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Client：192.168.56.100&lt;/p&gt;
&lt;p&gt;Server：192.168.56.101&lt;/p&gt;
&lt;p&gt;OS：CentOS Linux release 7.9.2009 (Core) 3.10.0-1160.el7.x86_64&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大致思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wmem 对应 &lt;code&gt;Send Buffer&lt;/code&gt;，从 TCP 的概念可以理解为 发送窗口，字母 &lt;code&gt;w&lt;/code&gt; 可以理解成 &lt;code&gt;write&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;rmem 对应 &lt;code&gt;Receive Buffer&lt;/code&gt;，从 TCP 的概念可以理解为 接收窗口&lt;/p&gt;
&lt;p&gt;实验过程是模拟一个下载过程，也就是大致过程是 &lt;code&gt;server&lt;/code&gt; 发送文件，所以调整 &lt;code&gt;wmwm&lt;/code&gt;，&lt;code&gt;client&lt;/code&gt; 接收文件，所以调整 rmen&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的如下：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;写死 Linux参数让传输速度慢下来
改接收端：sysctl -w "net.ipv4.tcp_rmem=4096  4096    4096"
或者
改发送端：sysctl -w "net.ipv4.tcp_wmem=4096  4096    4096" 

继续调整rtt、丢包率，curl限制速度等，抓包分析看到的所有现象&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;系统默认参数如下&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;sysctl&lt;span class="w"&gt; &lt;/span&gt;-a&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;egrep&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rmem|wmem|tcp_mem|adv_win|moderate&amp;quot;&lt;/span&gt;
net.core.rmem_default&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;212992&lt;/span&gt;
net.core.rmem_max&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;212992&lt;/span&gt;
net.core.wmem_default&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;212992&lt;/span&gt;
net.core.wmem_max&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;212992&lt;/span&gt;
net.ipv4.tcp_adv_win_scale&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
net.ipv4.tcp_mem&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;42459&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;56612&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;84918&lt;/span&gt;
net.ipv4.tcp_moderate_rcvbuf&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
net.ipv4.tcp_rmem&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;87380&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;6291456&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;//最小值&lt;span class="w"&gt;  &lt;/span&gt;默认值&lt;span class="w"&gt;  &lt;/span&gt;最大值
net.ipv4.tcp_wmem&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;16384&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;4194304&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;//最小值&lt;span class="w"&gt;  &lt;/span&gt;默认值&lt;span class="w"&gt;  &lt;/span&gt;最大值
net.ipv4.udp_rmem_min&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;
net.ipv4.udp_wmem_min&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;
vm.lowmem_reserve_ratio&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;256&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;256&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;32&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;开始命令&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Client &amp;amp;&amp;amp; Server&lt;/span&gt;
&lt;span class="nv"&gt;clientIP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;192.168.56.100&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;192.168.56.101&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# Server&lt;/span&gt;
&lt;span class="c1"&gt;# 启动命令的地方存在一个 2个多G 的文件&lt;/span&gt;
python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;SimpleHTTPServer&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;8089&lt;/span&gt;

&lt;span class="c1"&gt;## Client&lt;/span&gt;
curl&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:8089/iso.tar&lt;span class="w"&gt; &lt;/span&gt;--output&lt;span class="w"&gt; &lt;/span&gt;./result

&lt;span class="c1"&gt;# 测试宽带&lt;/span&gt;
iperf3&lt;span class="w"&gt; &lt;/span&gt;-s
iperf3&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-t&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;60&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="c1"&gt;# 无额外设置情况下宽带结果&lt;/span&gt;
大概是&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.69&lt;span class="w"&gt; &lt;/span&gt;Gbits/sec&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2860&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Mbps
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实验结果信息汇总&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;--正常&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;127&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;MB/s

--延时&lt;span class="w"&gt; &lt;/span&gt;100ms，5.48&lt;span class="w"&gt; &lt;/span&gt;MB/s
client&lt;span class="w"&gt; &lt;/span&gt;角度看的话，server发的包大小不稳定，60000-10000都有
server&lt;span class="w"&gt; &lt;/span&gt;是以比较稳定的处理包，然后有100ms的延时

--延时&lt;span class="w"&gt; &lt;/span&gt;100ms&lt;span class="w"&gt; &lt;/span&gt;且client&lt;span class="w"&gt; &lt;/span&gt;的&lt;span class="w"&gt; &lt;/span&gt;rmem&lt;span class="w"&gt; &lt;/span&gt;改成&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;，17&lt;span class="w"&gt; &lt;/span&gt;KB/s
client&lt;span class="w"&gt; &lt;/span&gt;角度来看，包比较乱
server&lt;span class="w"&gt; &lt;/span&gt;角度来说，连续小包（几千的样子）汇总发送,包的大小会有&lt;span class="w"&gt; &lt;/span&gt;重复递增的样子

--延时&lt;span class="w"&gt; &lt;/span&gt;100ms&lt;span class="w"&gt; &lt;/span&gt;且server&lt;span class="w"&gt; &lt;/span&gt;的&lt;span class="w"&gt; &lt;/span&gt;wmem&lt;span class="w"&gt; &lt;/span&gt;改成&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;，80&lt;span class="w"&gt; &lt;/span&gt;KB/s
client&lt;span class="w"&gt; &lt;/span&gt;角度来看，一个ACK，然后一个稳定的接收&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;8258&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;length&lt;span class="w"&gt; &lt;/span&gt;的包
server&lt;span class="w"&gt; &lt;/span&gt;是以比较稳定的处理包，然后有100ms的延时

--延时&lt;span class="w"&gt; &lt;/span&gt;10ms&lt;span class="w"&gt; &lt;/span&gt;且client&lt;span class="w"&gt; &lt;/span&gt;的&lt;span class="w"&gt; &lt;/span&gt;rmem&lt;span class="w"&gt; &lt;/span&gt;改成&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;，17&lt;span class="w"&gt; &lt;/span&gt;KB/s
client&lt;span class="w"&gt; &lt;/span&gt;角度来看，包比较乱
server&lt;span class="w"&gt; &lt;/span&gt;角度来说，连续小包（几千的样子）汇总发送,包的大小会有&lt;span class="w"&gt; &lt;/span&gt;重复递增的样子
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;实验记录&lt;/h1&gt;
&lt;h2&gt;实验一：正常状态&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Client&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;client_01.pcap
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;clientIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;server_01.pcap

&lt;span class="c1"&gt;# 下载结果 大概平均下载速度是 127 MB/s&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:8089/iso.tar&lt;span class="w"&gt; &lt;/span&gt;--output&lt;span class="w"&gt; &lt;/span&gt;./result_01
&lt;span class="w"&gt;  &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Total&lt;span class="w"&gt;    &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Received&lt;span class="w"&gt; &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Xferd&lt;span class="w"&gt;  &lt;/span&gt;Average&lt;span class="w"&gt; &lt;/span&gt;Speed&lt;span class="w"&gt;   &lt;/span&gt;Time&lt;span class="w"&gt;    &lt;/span&gt;Time&lt;span class="w"&gt;     &lt;/span&gt;Time&lt;span class="w"&gt;  &lt;/span&gt;Current
&lt;span class="w"&gt;                                 &lt;/span&gt;Dload&lt;span class="w"&gt;  &lt;/span&gt;Upload&lt;span class="w"&gt;   &lt;/span&gt;Total&lt;span class="w"&gt;   &lt;/span&gt;Spent&lt;span class="w"&gt;    &lt;/span&gt;Left&lt;span class="w"&gt;  &lt;/span&gt;Speed
&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;2539M&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;2539M&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;127M&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;:00:19&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;:00:19&lt;span class="w"&gt; &lt;/span&gt;--:--:--&lt;span class="w"&gt;  &lt;/span&gt;130M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到截图里，时间都是以 0.000X 秒递增的&lt;/p&gt;
&lt;p&gt;client_01 截图&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 250.23809523809524" &gt;&lt;img width="2102" height="420" src="https://raw.githubusercontent.com/iYangcw/Photo/master/client_01.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;server_01 截图&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 251.8028846153846" &gt;&lt;img width="2095" height="416" src="https://raw.githubusercontent.com/iYangcw/Photo/master/server_01.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;TCP  Windows  Scale&lt;/h3&gt;
&lt;p&gt;Window Scale 选项只能与 TCP SYN、SYN/ACK 一起使用。TCP 早期的时候带宽很小，所以最大接收窗口被定义成 65535 字节（ TCP Header 的 Windows 最大为 16 bit ）&lt;/p&gt;
&lt;p&gt;由于不够用，所以通过 TCP options 定义了 Windows  Scale，其声明了一个 Shift count，作为2的指数，再乘以 TCP 头中定义的接收窗口，就得到真正的 TCP 接收窗口了。&lt;/p&gt;
&lt;p&gt;下图为 SYN/ACK 中可以看到 Windows  Scale 为 7&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 81.04651162790698" &gt;&lt;img width="1394" height="860" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230420161433041.png" /&gt;&lt;figcaption&gt;image-20230420161433041&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下图为真实的 Windows size：29312 = 229 * 128&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 93.61147327249022" &gt;&lt;img width="1436" height="767" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230420161615849.png" /&gt;&lt;figcaption&gt;image-20230420161615849&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;Window size&lt;/h3&gt;
&lt;p&gt;TCP 层的 Windows size （或者如上述截图的 Windows 、Calculated windows size），是在向对方声明自己的&lt;strong&gt;接收窗口&lt;/strong&gt;，而不是发送窗口&lt;/p&gt;
&lt;p&gt;发送窗口决定了一口气能发多少字节，而 MSS 决定了这些字节要分多少个包发完。至于为什么 MSS=1460 的情况下，但是抓包的结果仍然有大于他的，这就是另外一个故事了，关键字：TCP Segment Offload&lt;/p&gt;
&lt;h2&gt;实验二：server 增加 100ms 延时&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Server&lt;/span&gt;
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;show&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;del&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;netem&lt;span class="w"&gt; &lt;/span&gt;delay&lt;span class="w"&gt; &lt;/span&gt;100ms
&lt;span class="c1"&gt;# Client&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;client_delay_100ms.pcap
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;clientIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;server_delay_100ms.pcap

&lt;span class="c1"&gt;# 结果，大概平均下载速度是 5.48 MB/s&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:8089/iso.tar&lt;span class="w"&gt; &lt;/span&gt;--output&lt;span class="w"&gt; &lt;/span&gt;./result
&lt;span class="w"&gt;  &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Total&lt;span class="w"&gt;    &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Received&lt;span class="w"&gt; &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Xferd&lt;span class="w"&gt;  &lt;/span&gt;Average&lt;span class="w"&gt; &lt;/span&gt;Speed&lt;span class="w"&gt;   &lt;/span&gt;Time&lt;span class="w"&gt;    &lt;/span&gt;Time&lt;span class="w"&gt;     &lt;/span&gt;Time&lt;span class="w"&gt;  &lt;/span&gt;Current
&lt;span class="w"&gt;                                 &lt;/span&gt;Dload&lt;span class="w"&gt;  &lt;/span&gt;Upload&lt;span class="w"&gt;   &lt;/span&gt;Total&lt;span class="w"&gt;   &lt;/span&gt;Spent&lt;span class="w"&gt;    &lt;/span&gt;Left&lt;span class="w"&gt;  &lt;/span&gt;Speed
&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;2539M&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;2539M&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;5619k&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;:07:42&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;:07:42&lt;span class="w"&gt; &lt;/span&gt;--:--:--&lt;span class="w"&gt; &lt;/span&gt;4563k
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;server 抓包详情&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 218.38235294117646" &gt;&lt;img width="1485" height="340" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230501160506654.png" /&gt;&lt;figcaption&gt;image-20230501160506654&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Wireshark 菜单路径：Statistics &amp;gt;&amp;gt; TCP Stream Graphs &amp;gt;&amp;gt; Time Sequence （Stevens）&lt;/p&gt;
&lt;p&gt;Time Sequence （Stevens）图能看到两个点之间，time相减为 0.1秒&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 132.61851015801355" &gt;&lt;img width="2350" height="886" src="https://raw.githubusercontent.com/iYangcw/Photo/master/server_dely_100ms.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的实验过程中，Round Trip Time Graphs 看不出来 rtt 是固定 100ms 的。&lt;/strong&gt;但是可以通过点击 Switch Direction 来看出 rtt&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 83.79446640316206" &gt;&lt;img width="1272" height="759" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230501160602666.png" /&gt;&lt;figcaption&gt;image-20230501160602666&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;实验三：server 增加 100ms 延时，client 修改 rmem&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 两边原始值&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_wmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 16384 4194304&amp;quot;&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_rmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 87380 6291456&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# server&lt;/span&gt;
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;show&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;del&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;netem&lt;span class="w"&gt; &lt;/span&gt;delay&lt;span class="w"&gt; &lt;/span&gt;100ms
&lt;span class="c1"&gt;# client&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_rmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 4096 4096&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# Client&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;client_delayServer_100ms_rmem_Client_4096.pcap
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;clientIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;server_delayServer_100ms_rmem_Client_4096.pcap

&lt;span class="c1"&gt;# 结果, 大概平均下载速度是 17 KB/s&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:8089/iso.tar&lt;span class="w"&gt; &lt;/span&gt;--output&lt;span class="w"&gt; &lt;/span&gt;./result_01
&lt;span class="w"&gt;  &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Total&lt;span class="w"&gt;    &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Received&lt;span class="w"&gt; &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Xferd&lt;span class="w"&gt;  &lt;/span&gt;Average&lt;span class="w"&gt; &lt;/span&gt;Speed&lt;span class="w"&gt;   &lt;/span&gt;Time&lt;span class="w"&gt;    &lt;/span&gt;Time&lt;span class="w"&gt;     &lt;/span&gt;Time&lt;span class="w"&gt;  &lt;/span&gt;Current
&lt;span class="w"&gt;                                 &lt;/span&gt;Dload&lt;span class="w"&gt;  &lt;/span&gt;Upload&lt;span class="w"&gt;   &lt;/span&gt;Total&lt;span class="w"&gt;   &lt;/span&gt;Spent&lt;span class="w"&gt;    &lt;/span&gt;Left&lt;span class="w"&gt;  &lt;/span&gt;Speed
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;2539M&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;1399k&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;14436&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;51&lt;/span&gt;:14:22&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;:01:39&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;51&lt;/span&gt;:12:43&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;14458&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;截图见&lt;strong&gt;实验一&lt;/strong&gt;结论&lt;/p&gt;
&lt;h2&gt;实验四：server 增加 100ms 延时，server 修改wmem&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 两边原始值&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_wmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 16384 4194304&amp;quot;&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_rmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 87380 6291456&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;show&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;del&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;netem&lt;span class="w"&gt; &lt;/span&gt;delay&lt;span class="w"&gt; &lt;/span&gt;100ms
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_wmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 4096 4096&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Client&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;client_delayServer_100ms_wmem_Server_4096.pcap
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;clientIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;server_delayServer_100ms_wmem_Server_4096.pcap

&lt;span class="c1"&gt;# 结果, 大概平均下载速度是 80 KB/s&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:8089/iso.tar&lt;span class="w"&gt; &lt;/span&gt;--output&lt;span class="w"&gt; &lt;/span&gt;./result_03
&lt;span class="w"&gt;  &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Total&lt;span class="w"&gt;    &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Received&lt;span class="w"&gt; &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Xferd&lt;span class="w"&gt;  &lt;/span&gt;Average&lt;span class="w"&gt; &lt;/span&gt;Speed&lt;span class="w"&gt;   &lt;/span&gt;Time&lt;span class="w"&gt;    &lt;/span&gt;Time&lt;span class="w"&gt;     &lt;/span&gt;Time&lt;span class="w"&gt;  &lt;/span&gt;Current
&lt;span class="w"&gt;                                 &lt;/span&gt;Dload&lt;span class="w"&gt;  &lt;/span&gt;Upload&lt;span class="w"&gt;   &lt;/span&gt;Total&lt;span class="w"&gt;   &lt;/span&gt;Spent&lt;span class="w"&gt;    &lt;/span&gt;Left&lt;span class="w"&gt;  &lt;/span&gt;Speed
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;2539M&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;13&lt;/span&gt;.3M&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;81082&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt;:07:22&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;:02:52&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt;:04:30&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;81157&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure style="flex: 219.01960784313727" &gt;&lt;img width="2234" height="510" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230426200129823.png" /&gt;&lt;figcaption&gt;image-20230426200129823&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Window Scaling 截图，绿线后面稳定的时候，值是 182272，和抓包截图里 Client 的 win=182272 也对应的上，win 是 client 向对方声明自己的接收窗口。从下载网速来看也就是虽然 client 声明了自己的接收窗口很大，但是 server 端的 wmem 比较小，所以网速也不快。&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 79.36241610738254" &gt;&lt;img width="1892" height="1192" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230426193723153.png" /&gt;&lt;figcaption&gt;image-20230426193723153&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个笔直的蓝色线 对应的从 No 180-182，对应的大小为：2896、5792、8192，抓包见下面截图，和抓包详情截图的 Len 字段也对得上。&lt;/p&gt;
&lt;p&gt;wireshark 的 Length 列 减去 66 ，就等于包详情里的 Len，至于为什么是 66 不太清楚，但是可以从 ACK 响应是 66 辅助确认。&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 69.82758620689656" &gt;&lt;img width="1701" height="1218" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230426195023142.png" /&gt;&lt;figcaption&gt;image-20230426195023142&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;实验五：server 增加 10ms 延时，client 修改 rmem&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 两边原始值&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_wmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 16384 4194304&amp;quot;&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_rmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 87380 6291456&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;show&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;del&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root
tc&lt;span class="w"&gt; &lt;/span&gt;qdisc&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;dev&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;netem&lt;span class="w"&gt; &lt;/span&gt;delay&lt;span class="w"&gt; &lt;/span&gt;10ms
&lt;span class="c1"&gt;# client&lt;/span&gt;
sysctl&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;net.ipv4.tcp_rmem&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4096 4096 4096&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# Client&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;client_delayServer_10ms_rmem_Client_4096.pcap
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;clientIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;server_delayServer_10ms_rmem_Client_4096.pcap

&lt;span class="c1"&gt;# 结果, 大概平均下载速度是 123 KB/s&lt;/span&gt;
$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:8089/iso.tar&lt;span class="w"&gt; &lt;/span&gt;--output&lt;span class="w"&gt; &lt;/span&gt;./result_01
&lt;span class="w"&gt;  &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Total&lt;span class="w"&gt;    &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Received&lt;span class="w"&gt; &lt;/span&gt;%&lt;span class="w"&gt; &lt;/span&gt;Xferd&lt;span class="w"&gt;  &lt;/span&gt;Average&lt;span class="w"&gt; &lt;/span&gt;Speed&lt;span class="w"&gt;   &lt;/span&gt;Time&lt;span class="w"&gt;    &lt;/span&gt;Time&lt;span class="w"&gt;     &lt;/span&gt;Time&lt;span class="w"&gt;  &lt;/span&gt;Current
&lt;span class="w"&gt;                                 &lt;/span&gt;Dload&lt;span class="w"&gt;  &lt;/span&gt;Upload&lt;span class="w"&gt;   &lt;/span&gt;Total&lt;span class="w"&gt;   &lt;/span&gt;Spent&lt;span class="w"&gt;    &lt;/span&gt;Left&lt;span class="w"&gt;  &lt;/span&gt;Speed
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;2539M&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;20&lt;/span&gt;.6M&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;123k&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;:50:08&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;:02:50&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;:47:18&lt;span class="w"&gt;  &lt;/span&gt;123k
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;见 &lt;strong&gt;结论二&lt;/strong&gt; 截图&lt;/p&gt;
&lt;h2&gt;实验六：curl 增加速度控制&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# client &amp;amp; server 保持默认值不动，限速设置小一点，抓包分析更好一点，分别尝试了1k、100k、1M&lt;/span&gt;
curl&lt;span class="w"&gt; &lt;/span&gt;--limit-rate&lt;span class="w"&gt; &lt;/span&gt;1k&lt;span class="w"&gt; &lt;/span&gt;http://192.168.56.101:8089/iso.tar&lt;span class="w"&gt; &lt;/span&gt;--output&lt;span class="w"&gt; &lt;/span&gt;./result_04

&lt;span class="c1"&gt;# Client&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;serverIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;client_curl_1k.pcap
&lt;span class="c1"&gt;# Server&lt;/span&gt;
tcpdump&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;enp0s8&lt;span class="w"&gt; &lt;/span&gt;-n&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;clientIP&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;server_curl_1k.pcap
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TCP Window Full 意味着窗口填满，可以看下这篇文章，说的很详细：&lt;a href="https://www.golinuxcloud.com/wireshark-tcp-zero-window/"&gt;Analyse Slow Networks with TCP Zero Window&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 106.85344827586206" &gt;&lt;img width="2479" height="1160" src="https://raw.githubusercontent.com/iYangcw/Photo/master/image-20230427171447952.png" /&gt;&lt;figcaption&gt;image-20230427171447952&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1&gt;结论&lt;/h1&gt;
&lt;h2&gt;结论一：改小 client rmem 和 server wmem 来对比对速度的影响&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实验三 和 实验四&lt;/strong&gt;：平均下载速度为：17 KB/s 和 80 KB/s 的对比&lt;/p&gt;
&lt;p&gt;相比而言，server 改小了 wmen 速度还凑合，因为server 每次收到ack，立即释放 wmem 来发新的网络包 (内存级别的时延)；&lt;/p&gt;
&lt;p&gt;如果 client 的 rmem 比较小，当 rmem 满了到应用读走 rmem，rmem 有空闲后需要 rtt 时间反馈到 server 端，server 端才会继续发包。（网络级时延比内存级时延高几个数量级）&lt;/p&gt;
&lt;p&gt;一句话总结：就是 rmem 从有空到包进来会有很大的间隔 (rtt) , wmem 有空到写包进来没有时延。&lt;/p&gt;
&lt;p&gt;plantegg 任总的这张图反复看，能有点理解了&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 138.15165876777252" &gt;&lt;img width="3498" height="1266" src="https://raw.githubusercontent.com/iYangcw/Photo/master/server%20_wmem_client_%20rmem.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;时间比较&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 78.54077253218884" &gt;&lt;img width="732" height="466" src="https://raw.githubusercontent.com/iYangcw/Photo/master/time.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;分析 实验三和实验四中 server 端抓包的结果：&lt;/p&gt;
&lt;p&gt;实验三 rmen 的截图，从 No 15 开始看，差不多是 server &amp;gt; client，【TCP Window Full 过会看】然后 No 17 中，client &amp;gt; server ACK 回复，然后过了 0.1 秒，No 18 又开始发送给 client 了。&lt;/p&gt;
&lt;p&gt;而且 TCP Window Full 很频繁，窗口被填满了，所以下载的速度很慢。截图里能看到 client 的 win=1460。&lt;/p&gt;
&lt;p&gt;简单按照步骤描述下过程&lt;/p&gt;
&lt;p&gt;1、No 11: client 表示我的接收窗口为 1460&lt;/p&gt;
&lt;p&gt;2、No 12: server 表示我的接收窗口为 29056，以及发送了 730 长度的包&lt;/p&gt;
&lt;p&gt;3、No 13: server 继续发送了 730 长度的包，由于 730 + 730 等于 client 的接收窗口 1460，所以提示 TCP WIndow Full&lt;/p&gt;
&lt;p&gt;4、No 14: client 继续说我的接收窗口为 1460&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 153.87596899224806" &gt;&lt;img width="2382" height="774" src="https://raw.githubusercontent.com/iYangcw/Photo/master/rmem_client_4096.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;实验四 wmen 的截图，server 几个包发给 client，然后 client ack 回复，反复该过程，包的发送比较平稳&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 157.04225352112675" &gt;&lt;img width="2230" height="710" src="https://raw.githubusercontent.com/iYangcw/Photo/master/wmem_server_4096.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;结论二：rmem 改小，查看 调整 rrt 后来对比速度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实验三 和 实验五&lt;/strong&gt; 都是修改 client rmen = 4096，只是一个是 server 端设置了 100ms 和 10ms 延时，但是结果是 17 KB/s 和 123 KB/s 的差距。&lt;/p&gt;
&lt;p&gt;rrt 增大了，下载速度会下降。下面两个截图，10ms 的 window Scaling 和 Throughput 都要比 100ms 的密集&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 155.5194805194805" &gt;&lt;img width="1916" height="616" src="https://raw.githubusercontent.com/iYangcw/Photo/master/rmem.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 152.70700636942675" &gt;&lt;img width="1918" height="628" src="https://raw.githubusercontent.com/iYangcw/Photo/master/throughput.png" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;plantegg 任总的这张图反复看【&lt;strong&gt;结论二的只需要看图片左边即可&lt;/strong&gt;】，能有点理解了&lt;/p&gt;
&lt;p&gt;延时增加了，那说明链路上的包也多了，client 接收包的速度慢了，那自然下载速度变慢。&lt;/p&gt;
&lt;p&gt;&lt;figure style="flex: 81.1449159327462" &gt;&lt;img width="4054" height="2498" src="https://raw.githubusercontent.com/iYangcw/Photo/master/rmem_rtt.png" /&gt;&lt;figcaption&gt;rmem_rtt&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;结论三：汇总：网速和 wmem rmem rtt 带宽 的关系&lt;/h2&gt;
&lt;p&gt;减少 rtt 和 增大带宽 影响带宽就不说了。&lt;/p&gt;
&lt;p&gt;client 的 recv buffer 太小 且 rtt 很大的情况下，网速会变慢。&lt;/p&gt;
&lt;p&gt;增加 server 的 send buffer （对应 wmem），相当于仓库发货比较强&lt;/p&gt;
&lt;p&gt;增加 client 的 recv buffer （对应 rmem），相当于仓库收获比较强&lt;/p&gt;
&lt;h1&gt;ss 计算 tcp buffer size&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://man7.org/linux/man-pages/man8/ss.8.html"&gt;man ss 链接&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 注意下，tb 表示 snd_buf，字母 t 可以理解为 Transmit&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;-m,&lt;span class="w"&gt; &lt;/span&gt;--memory
&lt;span class="w"&gt;              &lt;/span&gt;Show&lt;span class="w"&gt; &lt;/span&gt;socket&lt;span class="w"&gt; &lt;/span&gt;memory&lt;span class="w"&gt; &lt;/span&gt;usage.&lt;span class="w"&gt; &lt;/span&gt;The&lt;span class="w"&gt; &lt;/span&gt;output&lt;span class="w"&gt; &lt;/span&gt;format&lt;span class="w"&gt; &lt;/span&gt;is:

&lt;span class="w"&gt;              &lt;/span&gt;skmem:&lt;span class="o"&gt;(&lt;/span&gt;r&amp;lt;rmem_alloc&amp;gt;,rb&amp;lt;rcv_buf&amp;gt;,t&amp;lt;wmem_alloc&amp;gt;,tb&amp;lt;snd_buf&amp;gt;,
&lt;span class="w"&gt;                            &lt;/span&gt;f&amp;lt;fwd_alloc&amp;gt;,w&amp;lt;wmem_queued&amp;gt;,o&amp;lt;opt_mem&amp;gt;,
&lt;span class="w"&gt;                            &lt;/span&gt;bl&amp;lt;back_log&amp;gt;,d&amp;lt;sock_drop&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;待办&lt;/h1&gt;
&lt;p&gt;BDP&lt;/p&gt;
&lt;p&gt;丢失率&lt;/p&gt;
&lt;h1&gt;参考链接&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://www.golinuxcloud.com/wireshark-tcp-zero-window/"&gt;Analyse Slow Networks with TCP Zero Window&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://plantegg.github.io/2019/09/28/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82TCP--%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6Buffer%E7%9A%84%E5%85%B3%E7%B3%BB/"&gt;TCP性能和发送接收窗口、Buffer的关系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/dog250/article/details/113020804"&gt;长肥管道(LFT)中TCP的艰难处境与打法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cisco.com/c/en/us/support/docs/ip/transmission-control-protocol-tcp/200943-Why-Your-Application-only-Uses-10Mbps-Ev.html"&gt;Why Your Application only Uses 10Mbps Even the Link is 1Gbps?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.switch.ch/network/tools/tcp_throughput/"&gt;TCP Throughput Calculator&lt;/a&gt;&lt;/p&gt;
</description><author>test@email.com (Sai)</author><guid isPermaLink="true">/Blog-With-GitHub-Boilerplate/archives/TCP发送窗口、接收窗口、wmem、rmem 关系/</guid><pubDate>Mon, 01 May 2023 14:00:00 +0806</pubDate></item></channel></rss>